[{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios的使用 ","date":"2023-12-29","objectID":"/posts/vuep11.html/:1:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios简介 使用背景：在实际项目开发中，前端页面所需要的数据往往需要从服务器端获取，这必然涉及与服务器的通信。 Axios主要是前端的一个网络请求框架，大部分基于Ajax Axios基于promise网络请求库，作用与node.js和浏览器中。 Axios在浏览器端使用XMLHttpRequests发送网络请求，并能自动完成JSON数据的转换。 地址 https://www.axios-http.cn/ ","date":"2023-12-29","objectID":"/posts/vuep11.html/:1:1","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios的安装和导入 安装：输入 npm install axios 导入：在文件开头输入 import axios from 'axios' ","date":"2023-12-29","objectID":"/posts/vuep11.html/:1:2","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios发送请求的方式 这可以与Springboot的GetMapping对应 发送GET请求（通过url传参） 示例代码如下： //向给定ID的用户发起请求 axios.get('/user?ID=12345') .then(function(response){ //若处理成功 console.log(response); }) .catch(function(error){ //若处理失败 console.log(error); }) .then(function(){ //总是执行 }); //上述请求也可以按以下方式完成 axios.get('/user',{ params:{ ID:12345 } }) .then(function(response){ //若处理成功 console.log(response); }) .catch(function(error){ //若处理失败 console.log(error); }) .then(function(){ //总是执行 }); 关于上述代码： 如果请求成功，系统会调用.then()；如果请求失败或出现错误，则会调用.catch()。 .then()与.catch()就是promise相关的语法。 .then()内需要传入一个回调函数（function(response)），.catch()也需要传入一个回调函数（function(error)），这些都是自定义的函数。 get请求如果想给后端传递数据，可以通过? String的方式传参（Springboot的时候说过）；如果参数较多，可以通过params（在后面再传一个参，参数是对象，对象内可以放多种配置）传参。 最后可以加一个.then()方法，不论成功或失败都执行该方法。 发送POST请求（通过请求体传参） 示例代码如下： axios.post('/user',{ firstName:'Fred', lastName:'Flintstone' }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) 关于上述代码： 用{}括起来，就会放在请求体内传参，而且需要注意的是：Axois会自动把请求体里面的数据转为JSON格式传送给后端。后端处理POST请求时，需要注意它是JSON的格式，作特殊的处理。 异步回调问题 //async/await的用法 async function getUser(){ try{ const response = await axios.get('/user?ID=12345'); console.log(response); }catch(error){ console.log(error); } } JavaScript最新的标准里面，有async和await的语法结构。 前面GET和POST都涉及了异步回调获取数据的形式，如果需要同步获取数据，则可以通过前面加一个async（方法内必须有配对的await）实现。 当方法前面加了async之后，发送异步请求的前面就可以加上await，无需再添加回调函数（即.then()），直接拿到响应，以同步的形式取代异步的编程。 不过常用的还是加回调函数的方式。 其他请求方式 参考： https://axios-http.com/zh/docs/req_config 更详细的配置项可以去官网文档查询。 ","date":"2023-12-29","objectID":"/posts/vuep11.html/:1:3","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"与Vue整合 axios不能直接写在\u003cscript\u003e标签内，因为网络请求下来的数据最终还是要交给data的。 目前虽然data中的电影信息是我们自己写的，但这些数据本应该是从数据库中查询出来交给前端的，最终再放在data里面去。 因为这个请求最终需要交给data，所以axios需要写在vue范围内（即export default{}内）。 Vue内部提供的一些生命周期的函数，即对于我们现在的组件App.vue来讲，从创建到加载、渲染、销毁，每一个阶段会有对应的函数。[例如：该组件在程序运行时会被创建，接下来加载到界面（绑定/挂载到界面），当页面切换了（即切换到其他组件上了），该组件就会被销毁] 其中，created要和data平级（不能放在methods:里面，这里面放的是自定义的函数），当组件被创建的时候，created:function()会被自动调用。 还有一个类似的方法叫mounted，这个方法作用时间会稍微迟一点，被挂载（渲染到界面上）的时候调用。（其他的方法可以在vue官网上查看。） 示例代码如下： ...... \u003cscript\u003e import Movie from './compents/Movie.vue' import Hello from './compents/Hello.vue' import axios from 'axios' export default{ name:'App', data:function(){ return{ movies:[ {id:1,title:\"金刚狼1\",rating:8.7}, {id:1,title:\"金刚狼2\",rating:8.8}, {id:1,title:\"金刚狼3\",rating:8.6}, ] } }, components:{ Movie, Hello } } \u003c/script\u003e ...... ","date":"2023-12-29","objectID":"/posts/vuep11.html/:2:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域 ","date":"2023-12-29","objectID":"/posts/vuep11.html/:3:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"和后端进行关联 首先，需要修改后端启动的端口：server.port=8088，再启动。 在created:function(){}里面写的axois.get(\"\")，它这个链接的发送需要有一个后端的接口。（比如说，想要控制器查询所有的用户，url访问其中的一个控制器，localhost:8088/user/findAll，就能看见所有的数据。）（TIPS：一般来说如果要查看问题，可以在网页处右键→检查→network） 所以axois.get(\"\")里面写↓ axios.get(\"http://localhost:8088/user/findAll\").then(function(response){console.log(response)}) 该处get请求一经发送，正好对应后端的@GetMapping，于是就拿到数据。（注意，虽然created先执行，但是里面的console.log()是异步回调函数，所以输出的文本先后并不代表方法调用的先后） 但是！还是会失败并报错的！ 这是跨域问题引起的↓ ","date":"2023-12-29","objectID":"/posts/vuep11.html/:3:1","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域问题 为什么会出现跨域问题 为了保证浏览器的安全,不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源，称为同源策略,同源策略是浏览器安全的基石 同源策略(Sameoriginpolicy) 是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源(即指在同一个域)就是两个页面具有相同的协议(protocol) ，主机(host) 和端口号(port) 当一个请求url的协议、 域名、端口三者之间任意-个与当前页面url不同即为跨域，此时无法读取非同源网页的Cookie,无法向非同源地址发送AJAX请求 跨域问题解决 CORS (Cross-Origin Resource Sharing)是由W3C制定的一种跨域资源共享技术标准，其目的就是为了解决前端的跨域请求。 CORS可以在不破坏即有规则的情况下，通过后端服务器实现CORS接口,从而实现跨域通信。 CORS将请求分为两类：简单请求和非简单请求，分别对跨域通信提供了支持。 简单请求的服务器处理 对于简单请求，CORS的策略是请求时在请求头中增加一个Origin字段 Host:localhost:8080 Origin:http://localhost:8081 Referer:http://localhost:8081/index.html 服务器收到请求后， 根据该字段判断是否允许该请求访问，如果允许，则在HTTP头信息中添加Access-Control- Allw-Origin字段。 Access-Control-Allow-Origin:http://localhost:8081 Content-Length:20 Content-Type:text/plain;charset=UTF-8 Date:Thu,12 Jul 2018 12:51:14 GMT 非简单请求 对于非简单请求的跨源请求，浏览器会在真实请求发出前增加一次OPTION请求，称为预检请求(preflight request) 预检请求将真实请求的信息，包括请求方法、自定义头字段、源信息添加到HTTP头信息字段中，询问服务器是否允许这样的操作。 例如一个GET请求: OPTIONS/test HTTP/1.1 origin:http://ww.test.com Access-Control-Request-Method:GET Access-Control-Request-Headers:X-Custom-Header Host:www.test.com Access-Control-Request-Method表示请求使用的HTTP方法，Access-Control-Request-Headers包含请求的自定义头字段 服务器收到请求时，需要分别对Origin、 Access-Control-Request-Method、Access-Control-Request-Headers进行验证，验证通过后，会在返回HTTP头信息中添加: Access-Control-Allow-Origin: http://www.test.com Access-Control-Allow-Methods: GET,POST,PUT,DELETE Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials:true Access-Control-Max-Age: 1728000 Access-Control-Allow-Methods、Access -Control-Allow-Headers:真实请求允许的方法、允许使用的字段 Accss-Control-Allow-Credentials: 是否允许用户发送、处理cookie Access-Control-Max-Age:预检请求的有效期，单位为秒，有效期内不会重新发送预检请求。 Spring Boot中配置CORS 在传统的Java EE开发中，可以通过过滤器统- -配置, 而Spring Boot中对此则提供了更加简洁的解决方案： @Configuration public class CorsConfig implementa WebMvcConfigurer { @override public vo1d addCorsMappingg(CorsRegistry registry){ registry.addMapping(\"/**\")//允许跨域访问的路径 .allowedOrigins(\"*\")//允许跨域访问的源 .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\")//允许请求方法 .maxAge(168000)//预检间隔时间 .allowedHeaders(\"*\") //允许头部设置 .allowCredentials(true);//是否发送cookie } } ","date":"2023-12-29","objectID":"/posts/vuep11.html/:3:2","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域问题解决方法 在控制器之前加注解@CrossOrigin，使得控制器里面所有的方法都允许被跨域。要么就加一个配置类，使得所有的控制器都能被跨域。（加完之后重启服务器） 拿到以后渲染到界面上：赋值给data，把response.data取出来，显示到表格里面。直接this.tableData = response.data就可以了。 解决回调函数this作用域的限制：改写.成then(response)=\u003e{} 每个组件都要导入axios，以及写相同的域名localhost:8088，可以抽出来进行整合。（在main.js里面做一个统一的导入） 与Vue整合 在实际项目开发中，几乎每个组件中都会用到axios发起数据请求。此时会遇到如下两个问题: 每个组件中都需要导入axios 每次发请求都需要填写完整的请求路径 可以通过全局配置的方式解决上述问题(写入main.js): //配置请求根路径 axios.defau1ts.baseURL = 'http://api.com' //将axios 作为全局的自定义属性，每个组件可以在内部直接访问(Vue3) app.config.globalProperties.$http = axios //将axios 作为全局的自定义属性，每个组件可以在内部直接访间(Vue2) Vue.prototype.$http = axios ","date":"2023-12-29","objectID":"/posts/vuep11.html/:3:3","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11.html/"},{"categories":["测试文档"],"content":"这是显示在章前图片的一段文字","date":"2023-12-13","objectID":"/posts/test.html/","tags":["测试"],"title":"测试文档","uri":"/posts/test.html/"},{"categories":["测试文档"],"content":"TEST ","date":"2023-12-13","objectID":"/posts/test.html/:1:0","tags":["测试"],"title":"测试文档","uri":"/posts/test.html/"},{"categories":["测试文档"],"content":"TEST TEST TEST 这是一个TEST文档 ","date":"2023-12-13","objectID":"/posts/test.html/:1:1","tags":["测试"],"title":"测试文档","uri":"/posts/test.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"组件间的传值 组件可以由内部的Data提供数据，也可以由父组件通过prop的方式传值 兄弟组件之间可以通过Vuex等统一数据源提供数据共享 项目创建（Vue2） 终端输入 vue create component-demo 把Linter取消选中 选择Vue2 创建 Vue2与Vue3的差异（主要在main.js中）： Vue3通过create app创建Vue对象，Vue2通过new Vue创建Vue对象 Vue3使用的是.mount，Vue2使用的是.$mount ","date":"2023-12-12","objectID":"/posts/vuep10.html/:1:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Element-ui Element是国内饿了么公司提供的一套开源前端框架，简洁优雅，提供了Vue、React、Angular等多个版本。 文档地址：https://element.eleme.cn/#/zh-CN/ 安装： npm i element-ui 引入Element （如果node_modules没了，可以直接npm install重新下载依赖） ","date":"2023-12-12","objectID":"/posts/vuep10.html/:2:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"第三方图标库FontAwesome 由于Element UI提供的字体图符较少，一般会采用其他图表库，如著名的FontAwesome Font Awesome提供了675个可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括大小、颜色、阴影或者其他任何支持的效果。 文档地址: http://fontawesome.dashgame.com/ 安装: npm install font-awesome 使用: import 'font-awesome/css/font-awesome.min.css' ","date":"2023-12-12","objectID":"/posts/vuep10.html/:3:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操代码 App.vue文件 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cMovie v-for=\"movie in movies\" :key=\"movie.id\" :title=\"movie.title\" :rating=\"movie.rating\"\u003e\u003c/movie\u003e \u003chello\u003e\u003c/hello\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Movie from './components/Movie.vue' import Hello from './components/hello.vue' import axios from 'axios' export default { name: 'App', data:function(){ return{ movies:[ {id:1,title:\"Tranformers1\",rating:8.9}, {id:2,title:\"Tranformers2\",rating:8.8}, {id:3,title:\"Tranformers3\",rating:8.7}, ] } }, created:function(){ console.log(\"APP组件被创建了\") }, components: { Movie, Hello } } \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e Movie.vue文件 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e{{title}}\u003c/h1\u003e \u003cspan\u003e{{rating}}\u003c/span\u003e \u003cbutton @click=\"fun\"\u003e点击收藏\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default {//导出，vue.app做导入，正好对应 name:\"Movie\", props:[\"title\",\"rating\"], data:function(){ return{ } }, created: function(){ console.log(\"Movie组件被创建了\") }, mounted:function(){ console.log(\"APP组件被创建了\") }, methods:{ fun(){ alert(\"收藏成功\") } } } \u003c/script\u003e hello.vue文件 \u003ctemplate\u003e \u003cdiv\u003e \u003cel-table :data=\"tableData\" style=\"width: 100%\" :row-class-name=\"tableRowClassName\"\u003e \u003cel-table-column prop=\"date\" label=\"日期\" width=\"180\"\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"name\" label=\"姓名\" width=\"180\"\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"address\" label=\"地址\"\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e \u003cel-date-picker v-model=\"value1\" type=\"date\" placeholder=\"选择日期\"\u003e \u003c/el-date-picker\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e .el-table .warning-row { background: oldlace; } .el-table .success-row { background: #f0f9eb; } \u003c/style\u003e \u003cscript\u003e export default { methods: { tableRowClassName({row, rowIndex}) { if (rowIndex === 1) { return 'warning-row'; } else if (rowIndex === 3) { return 'success-row'; } return ''; } }, data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } } } \u003c/script\u003e ","date":"2023-12-12","objectID":"/posts/vuep10.html/:4:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"NPM使用 NPM简介 NPM (Node Package Manager)是一个NodeJS包管理和分发工具。 NPM以其优秀的依赖管理机制和庞大的用户群体，目前已经发展成为整个JS领域的依赖管理工具 NPM最常见的用法就是用于安装和更新依赖。要使用NPM，首先要安装Node工具。 ","date":"2023-12-11","objectID":"/posts/vuep9.html/:1:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"NPM\u0026Vue下载安装 进入https://nodejs.org/en网站下载Node.js 打开msi安装包一直点击next完成安装 win+R打开终端，进入项目路径，输入 npm install -g @vue/cli （网络问题可以先输入下面代码更换代理再安装） npm config set registry https://registry.npm.taobao.org ","date":"2023-12-11","objectID":"/posts/vuep9.html/:2:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue CLI使用 ","date":"2023-12-11","objectID":"/posts/vuep9.html/:3:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建Vue项目 输入 vue create hello 上下键切换选项，选择Manually select features选项，并回车 上下切换选项，空格选中/取消选中，空格取消选中Linter/Formatter选项，并回车 选择3.x版本并回车 选择不存储预选，输入N ","date":"2023-12-11","objectID":"/posts/vuep9.html/:3:1","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue文件基本结构 package.json：配置文件，记录项目基本信息 src：写代码的目录 main.js:主要用到模块化开发的思想（区别于组件化），目前前端项目基本通过import的方式导入各类模块。（早期的前端代码主要通过script标签去引入各类文件） 第一行：通过vue导入其createApp方法 第二行：导入了app.vue的app 调用createApp方法，把app传过去，同时将其mount到了#app标签上（标签在public的index.html里） main.js全部代码如下： import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') Vue.app： \u003ctemplate\u003e：放组件的标签、文本、结构，放置了： img标签 helloworld标签（自定义组件，在components里面，可以删掉自己写） \u003cscript\u003e:放组件的一些行为 \u003cstyle\u003e：放组件的一些css的样式 Vue.app全部代码如下：： \u003ctemplate\u003e \u003cimg alt=\"Vue logo\" src=\"./assets/logo.png\"\u003e \u003cHelloWorld msg=\"Welcome to Your Vue.js App\"/\u003e \u003c/template\u003e \u003cscript\u003e import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components: { HelloWorld } } \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e ","date":"2023-12-11","objectID":"/posts/vuep9.html/:3:2","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"运行Vue项目 打开终端，输入： npm run serve ","date":"2023-12-11","objectID":"/posts/vuep9.html/:3:3","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"自定义组件 使用import导入,例如： import HelloWorld from './components/HelloWorld.vue' 导入结束后进行注册: export default { name: 'App', components: { HelloWorld } } (1、2步代码都放在script内) 创建.vue文件自定义组件：添加\u003ctemplate\u003e、\u003cscript\u003e、\u003cstyle\u003e标签,在标签里简单加入内容即可 (可以安装Vetur插件着色代码） ","date":"2023-12-11","objectID":"/posts/vuep9.html/:3:4","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"\r信息\r需要前端基础html、css、js\r","date":"2023-12-06","objectID":"/posts/vuep8.html/:0:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue框架介绍 vue是一套用于构建用户界面的渐进式框架。 vue.js提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。 其目标是通过尽可能简单的API实现响应式的数据绑定和可组合的视图组件。 ","date":"2023-12-06","objectID":"/posts/vuep8.html/:1:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"MVVM模式 MVVM基于MVC（Model-View-Controller)但是在Controller上作了修改 MVVM是Model-View-ViewModel的缩写，它是一种基于前端开发的架构模式，其核心是提供对View和ViewModel的双向数据绑定。 Vue提供了MVVM风格的双向数据绑定。核心是MVM中的VM，也就是 ViewModel,ViewModel负责连接View和Model，保证视图和数据的一致性。 ","date":"2023-12-06","objectID":"/posts/vuep8.html/:2:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 （使用VScode） 创建html文件，使用！+Enter，生成代码，去代码copy链接↓ \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 调用CreateApp的方法，且告知渲染至哪（扩展→Open in browser插件，run的时候就能从浏览器快速打开） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e{{ message }}\u003c/div\u003e \u003cscript\u003e const { createApp } = Vue createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 演示代码文件: “：”后为变量或表达式，属性的绑定需要加“：”，不加会变成字段。 01. 基本用法 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e{{ message }}\u003c/div\u003e \u003cscript\u003e const { createApp } = Vue createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 02. 内容渲染指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cp\u003e姓名:{{username}}\u003c/p\u003e \u003cp\u003e性别：{{gender}}\u003c/p\u003e \u003c!-- 花括号是vue里面的data模板，会做一些渲染。 对http不会进行渲染，但是使用v-html可以进行渲染 --\u003e \u003cp\u003e{{desc}}\u003c/p\u003e \u003cp v-html=\"desc\"\u003e\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data:function(){ return{ username:'zhangsan', gender:'男', desc:'\u003ca href=\"http://www.baidu.com\"\u003e百度\u003c/a\u003e' } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 03. 属性绑定指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ca :href=\"link\"\u003e百度\u003c/a\u003e \u003c!-- 冒号就是进行渲染，这里把link放在这，vue就会把值渲染到超链接上 --\u003e \u003cinput type=\"text\" :placeholder=\"inputValue\"\u003e \u003cimg :src=\"imgSrc\" :style=\"{width:w}\" alt=\"\"\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data: function(){ return{ link:\"http://www.baidu.com\", //文本框的占位符内容 inputValue:'请输入内容', //图片的src地址 imgSrc:'./images/demo.png', w:'500px' } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 04. 使用JavaScript表达式 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cp\u003e{{number + 1}}\u003c/p\u003e \u003cp\u003e{{ok ? 'True' : 'False'}}\u003c/p\u003e \u003cp\u003e{{message.split('').reverse().join('')}}\u003c/p\u003e \u003cp :id=\"'list-' + id\"\u003exxx\u003c/p\u003e \u003cp\u003e{{user.name}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data :function(){ return{ number:9, ok:false, message:'AAA+ABC', id:3, user:{ name:'zs', } } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 05. 事件绑定指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch3\u003ecount的值为：{{count}}\u003c/h3\u003e \u003cbutton v-on:click=\"addCount\"\u003e+1\u003c/button\u003e \u003cbutton @click=\"count+=1\"\u003e+1\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data:function(){ return{ count:0, } }, methods:{ //点击按钮，让count+1 addCount(){ this.count+=1 }, }, } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 06. 条件渲染指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cbu","date":"2023-12-06","objectID":"/posts/vuep8.html/:2:1","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mybatis多表查询 实现复杂关系映射，可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置。 注解 说明 @Reults 代替标签,该注解中可以加入单个或多个@Result注解 @Result 代替标签和标签，@Result中可以使用以下属性: - column: 数据表的字段名称 - property:类中对应的属性名 - one:与@one注解配合，进行一对一的映射 - many: 与@Many注解配合，进行一对多的映射 @One 代替标签，用于指定查询中返回的单一对象 通过select属性指定用于多表查询的方法 使用格式:@Result(column=\"\",property=\"\",one=@one(select=\"\")) @Many 代替标签,用于指定查询中返回的集合对象 使用格式:@Result(column=\"\",property=\"\",many=@Many(select=\"\")) 实际使用 要查同一用户下的所有订单：加入一个字段orders，字段orders并不存在，其属性为List集合，存放的是订单对象Orders。 TableName(\"t_user\") public class User { @TableId(type = IdType .AUT0) private int id; priwate string username ; private string password; private string birthday ; //描述用户的所有订单 @TableField(exist = false) private List\u003c0rder\u003eorders; //alt + insert ………… 这个字段需要自行映射 ………… //查询用户及其所有的订单 @Select(\"\"select * from t_user\"\") @Results( { @Result(column = \"id\" , property = \"id\"), @Result(column = \"username\" , property = \"username\"), @Result(column = \"password\" , property = \"password\"\"), @Result(column = \"birthday\" , property = \"birthday\"\") , @Result(column = \"id \" , property = \"orders\",javaType = List.class, many=@Many(select = \"com.example.mpdemo.mapper.OrderMapper.selectBy…… ) } } List\u003cUser\u003e selectAllUserAnd0rders(); } 前面意思是↑从数据库里面调取的id这一列需要赋值给user类中的id属性。 关键在于映射orders：最后一行，标记需要使用id字段，需要映射orders，类型为集合list。还需要写一个方法： @Select(\"select * from t_order where uid = #{uid}\") List\u003cOrder\u003e selettByUid(int uid); many注解，意思是一个用户会有多个订单，后接需要调用哪个mapper的哪个方法（对着mapper右键copy path选最后一个就行）,查询出来的订单最后传给了orders属性，就完成了映射。 如果我们需要查订单的用户：需要用one注解 one=@0ne(select = \"com.example.mpdemo.mapper .UserHapper.selectById\") 条件查询： @GetMapping(\"/user/find\") public List\u003cUser\u003e findBycond(){ QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper(); queryWirapper.eq( \"username\" , \"zhangsan\"); return userMapper.selectList(queryWrapper); } 分页查询： @GetMapping(\"/user/findByPage\") public IPage findByPage(){ //设置起始值及每页条数 Page\u003cUser\u003e page = new Page\u003c\u003e(0, 2) ; IPage iPage = userMapper.selectPage(page, null); return iPage; } ","date":"2023-12-05","objectID":"/posts/springbootp7.html/:1:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·MybatisPlus多表查询及分页查询","uri":"/posts/springbootp7.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"ORM ORM (Object Relational Mapping,对象关系映射）是为了解决面向对象与关系数据库存在的互不匹配现象的一种技术。 ORM通过使用描述对象和数据库之间映射的元数据将程序中的对象自动持久化到关系数据库中。 ORM框架的本质是简化编程中操作数据库的编码。 ","date":"2023-12-04","objectID":"/posts/springbootp6.html/:1:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mybatis-Plus ","date":"2023-12-04","objectID":"/posts/springbootp6.html/:2:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"介绍 MyBatis是一款优秀的数据持久层ORM框架。被广泛地应用于应用系统。 MyBatis能够非常灵活地实现动态SQL。可以使用XML或注解来配置和映射原生信息。能够轻松地将Java的POJO(Plain Ordinary Java Object，普通的Java对象)与数据库中的表和字段进行映射关联。 MyBatis-Plus是一个MyBatis的增强工具。在MyBatis的基础上做了增强。简化了开发。 ","date":"2023-12-04","objectID":"/posts/springbootp6.html/:2:1","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置 添加依赖到pom.xml：（MybatisPlus其实依赖了Mybatis）（需要准备好Mysql数据库） \u003c!--MyBatisP1us依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.4.2\u003c/version\u003e \u003c/dependency\u003e \u003c! -- mysq1驱动依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysq1-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--数据连接池druid--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.a1ibaba\u003c/groupId\u003e \u003cartifactid\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.20\u003c/version\u003e \u003c/dependency\u003e 加入配置（在.properties)：（使用什么连接池\\数据库、数据库在哪、账号\\密码、日志输出格式）（数据库的组件都在mapper包里，需要给出mapper包路径） ","date":"2023-12-04","objectID":"/posts/springbootp6.html/:2:2","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 加入控制器 定义mapper相关的组件（要创建的是接口，不是类，名称都以要操作的表+mapper命名）（sql语句都用@注解来实现） 新建user类，存储表中有的字段。（按住alt+insert加入get/set方法）（再加一个toString方法） 加入注解使得方法生效@select(“select * from user”)(记得加入@mapper) 通过@autowired注入参数usermapper内容，再使用find()方法返回用户列表。 改成JSON 插入user对象 int insert()代表插入几条记录，插入失败返回值为0 mysql插入会自增 mybatis会自动帮助你增删改，不需要再自写方法了，只需要告诉其user类 mybatis-plus：当表明与类名不一样时@TableName(“表名“），（以告知mybatis）如果需要id作为组件自增@TableId(type=IdType.AUTO)。 如果不加的话，数据库里面的id可能是自增的值，但是代码print不出来id的值 ","date":"2023-12-04","objectID":"/posts/springbootp6.html/:2:3","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful服务 ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:1:0","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful介绍 RESTful是一种软件服务架构设计风格 ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:1:1","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful特点 例如，将请求清晰分类，GET用于获取，POST用于新建，等等等等 每一个URI代表一种资源。 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作:GET用于获取资源,POST用于新建资源(也可以用于更新资源)，PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的。从客户端到服务端的每个请求都包含必需的信息。 ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:1:2","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful API（符合此架构接口的必备特质） 符合RESTful规范的Web API需要具备如下两个关键特性: 安全性:安全的方法被期望不会产生任何副作用。当我们使用GET操作获取资源时。不会引起资源本身的改变，也不会引起服务器状态的改变。 幂等性:幂等的方法保证了重复进行一个请求和一次清求的效果相同（并不是指响应总是相同的,而是指服务器上资源的状态从第一次请求后就不再改变了），在数学上幂等性是指N次变换和一次变换相同。 在做BS架构程序时，想要符合RESTful风格，对应几种请求方法即可 实际编程时如何实现RESTful风格： Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API,提供了与REST操作方式(GET.POST、PUT、DELETE)对应的注解： GetMapping:处理GET请求，获取资源。 PostMapping:处理POST请求，新增资源。 putMapping:处理PUT请求，更新资源。 DeleteMapping:处理DELETE请求，删除资源。 PatchMapping:处理PATCH请求，用于部分更新资源。 URL中不要包含动词（传统的比如删除用户操作为http://xxx/del?id=10，但是RESTful需要delete http://xxx/user/10） 示例：（RESTful增删改查）（加**{}意味其为动态**，需要加入PathVariable注解） ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:1:3","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 全部代码如下 @RestController public class UserController { @GetMapping(\"/user/{id}\") public String getUserById(@PathVariable int id){ System.out.println(id); return \"根据ID获取用户信息\"; } @PostMapping(\"/user\") public String save(User user){return \"添加用户\";} @PutMapping(\"/user\") public String update(User user){return \"更新用户\";} @DeleteMapping(\"/user/{id}\") public String deleteById(@PathVariable int id){ System.out.println(id); return \"根据ID删除用户\"; } } ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:1:4","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Swagger Java内提供的测试工具 通过Swagger动态生成web接口文档（方便前端使用），也可以进行端口测试 ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:2:0","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置 在pom.xml加入依赖↓ \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e 警告\rSpring Boot 2.6.X后与Swagger有版本冲突问题，需要在application.properties中加入以下配置: spring.mvc.pathmatch.matching-strategy=ant_path_matcher\r然后做一个基本的配置↓（在config下创建一个SwaggerConfig配置类） @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis( RequestHandlerSelectors.basePackage(\"com\")) .paths(PathSelectors.any()).build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"演示项目API\")//标题 .description(\"学习Swagger2的演示项目\")//描述 //附加信息 .build(); } } ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:2:1","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"使用Swagger2进行接口测试 启动项目访问http://127.0.0.1:8080/swagger-ui.html，即可打开自动生成的可视化测试页面 ","date":"2023-12-03","objectID":"/posts/springbootp5.html/:2:2","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Web开发进阶 ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:1:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"静态资源访问 前后端分离static是不会存放内容的 ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:1:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 当没有配置静态资源时，直接 “/” 后接 静态资源 名称即可访问（例：localhost:8080/test.jpg） 如果不想放在根路径下直接访问，而希望在资源前面加一个统一路径images方便管理，可以通过static path设置虚拟路径（也叫过滤规则）:在application.properties中加入代码 spring.mvc.static-path-pattern=/images/** 如果在resource下额外创建了一个文件，将静态资源放在自创文件css中，则需要通过static locations进行修改（classpath是整个项目的类路径，在target下的classes，是一个固定的目录） spring.web.resources.static-locations=classpath:/css ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:1:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"文件上传 ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:2:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"文件上传原理 传输文件必须要把表单中的enctype（编码类型）改成form-data的类型。 （修改后，例如表单中的字符串字段，还是使用文本形式进行传输；但如果上传的字段是文件，则会与上一个分开，用另外的形式上传） 配置 在application.properties中加入 spring.servlet.multipart.max-file-size=10MB spring.servlet.multipart.max-request-size=10MB 在控制器方法中加入一个特殊的参数MultipartFile（Spring用来接收文件的类型）,通过此对象获取文件信息。 例如：public String upload(String nickname, MultipartFile photo, HttpServletRequest request) ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:2:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 如何动态获取web服务器所在位置（怎么去获取服务器对应路径）： 在方法里加入HttpServletRequest request参数（J2EE提供的原始类，代表网络请求，即前端发送的请求，一个request对象）: public String upload(String nickname, MultipartFile photo, HttpServletRequest request) 通过此对象可以获取该对象的上下文对象（request.getServletContext，也就是该请求的上下文）， 其实也就是web服务器，通过web服务器得到对应的路径（getRealPath)， 其实就得到了web服务器运行的目录，将其存储在自创的虚拟的/upload/目录中: String path = request.getServletContext().getRealPath(\"/upload/\"); 如果status：500，意味着后端出了问题（up是文件太大了） 通过自定义函数savefile判断目录是否存在，如果不存在，则使用path与文件名创建目录，最后使用transferTo方法把文件传输到创建好的目录中。 想让用户通过刚刚创建好的目录访问文件需要在applicaition.properties中加入代码： spring.web.resources/static-locations=/upload/ 全部代码如下 在Controller包下创建FileUploadController类 @RestController public class FileUploadController { @PostMapping(\"/upload\") public String upload(String nickname, MultipartFile photo, HttpServletRequest request)throws IOException{ System.out.println(nickname); System.out.println(photo.getOriginalFilename()); System.out.println(photo.getContentType()); String path = request.getServletContext().getRealPath(\"/upload/\"); System.out.println(path); saveFile(photo,path); return \"success upload\"; } public void saveFile(MultipartFile photo,String path)throws IOException{ File dir=new File(path); if (!dir.exists()){ dir.mkdir(); } File file=new File(path+photo.getOriginalFilename()); photo.transferTo(file); } } ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:2:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"拦截器 ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:3:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"有关拦截器 拦截器主要对于不同控制器可能遇见的统一操作（例如获取用户名），做一个处理 用户提交的请求都先到达（自定义的）拦截器，调用prehandle，最终到控制器的目标方法中，到页面渲染结束，再调用afterCompletion prehandle调用的最频繁（例如用户想要提交一个请求，但是没有登录，拦截器可以拦截下请求不让它直接到控制器调用方法，而是先登录） 如果要定义拦截器一般会在后面加Interceptor（然后继承一个系统的拦截器类HandlerInterceptor): public class LoginInterceptor implements HandlerInterceptor 拦截器还需要注册，否则无法使用（需要在Java类里面完成，继承WebMvcConfiguer，一个专门做配置器的类，对于刚才创建的拦截器进行一个Login，然后定义你需要拦截的路径）: public class WebConfig implements WebMvcConfigurer ······ registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/user/**\"); ······ ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:3:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实际操作 继承HandlerInterceptor（Ctrl+单击进入具体代码） 重写prehandle方法，写完之后还需要配置才生效（此配置一般放在config下）：创建一个类，加入注解Configuration使其生效（效果为Springboot会自动读取此类） 重写副类WebMvcConfigurer，里面提供了添加拦截器的方法 重写addInterceptors方法，调用其传递的registry对象，添加一个拦截器，将刚才Login的拦截器进行new，最后加入拦截路径（不加的话就是拦截所有，可以不加） 全部代码如下 创建Interceptor包，在下面创建LoginInterceptor类： public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler)throws Exception{ System.out.println(\"LoginInterceptor\"); return true; } } 在config下创建WebConfig类： @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry){ // registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/user/**\"); registry.addInterceptor(new LoginInterceptor()); } } ","date":"2023-12-02","objectID":"/posts/springbootp4.html/:3:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Web入门 Spring Web提供了启动器starter，主要包含了三个组件：mvc、json、tomcat。 webmvc组件主要提供web开发的注解（类似于控制器的注解）是web开发的基础框架 json组件主要提供了JSON数据的解析，使能够接收前端发送数据并返回 Tomcat为自带的容器依赖 ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:1:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"控制器 ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:2:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"控制器介绍 mvc为后端开发的一种模式：m为Model，用于存储收发数据；c为Controller，用于协调控制；v为View(视图)，是用来显示数据的。 在mvc模式下，从数据库中加载的数据首先被封装在Model中，通过Controller，绑定到View上（视图可以理解为html的页面）。 所以控制器负责接收将数据交给浏览器与接收用户请求。用户操作时，实际上是→对控制器发出请求→控制器取用数据→交给视图→最终响应给用户。 两种注解 @Controller(无法前后端分离）：既有页面又有数据。 @RestController：只有数据。RestController（为了方便前端处理）会将返回的对象数据转换为JSON格式。 ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:2:1","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"路由映射 控制器如何接收前端的请求 @RequestMapping(可以用在类或者方法上） value参数：用于配置路径，支持普通字符串与正则表达式。可以规定前端用什么方法请求（比如get或post） ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:2:2","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实际操作 使用@RequestMapping 加入value值：/hello。 使hello方法能够接收前端的请求，前端通过/hello路径能够访问到该方法。（在地址栏里面发送的请求都是get请求） 规定方法：加入method=RequestMethod.GET，规定只能通过get请求。(@RequestMapping(value=\"/hello\",method=RequestMethod.GET)等价于@GetMapping(\"/hello\")) ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:2:3","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"参数传递 @RequestParam可以将前端的数据绑定到控制器的方法上以获取前端传递的信息。当传参与参数名一致时可省略。 此时只需要在方法里面加入一个参数：String nickname，就可自动将前端输入的昵称传入nickname中。 传参与定义参数名不一致，可以在方法里加入@RequestParam(value = \"nickname\",required = false)String name （代表参数映射,加上这个注解，就代表这个参数是必须的，如果希望可选就加上required = false) （如果必须，没输入会报错，报错结果为status=400，400一般意味着是客户端，也就是浏览器出了问题） 全部代码如下 创建entity实体包，在entity下创建User类(按住alt+insert快捷加入get/set/to String方法) public class User { public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private String username; private String password; @Override public String toString() { return \"User{\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 在Controller包下创建ParamsController控制器类(后面的POST方法用APIPOST可以调试) @RestController public class ParamsController { @RequestMapping(value = \"/getTest1\",method = RequestMethod.GET) public String getTest1(){ return \"Get请求\"; } @RequestMapping(value =\"/getTest2\",method = RequestMethod.GET) public String getTest2(String nickname,String phone){ System.out.println(\"nickname\"+nickname); System.out.println(\"phone\"+phone); return \"GET请求\"; } @RequestMapping(value = \"/getTest3\",method = RequestMethod.GET) public String getTest3(@RequestParam(value = \"nickname\",required = false)String name){ //↑注解，代表参数映射，表示如果传参名字与参数不一致，就映射nickname System.out.println(\"nickname\"+name); return \"GET请求\"; } @RequestMapping(value = \"/postTest1\",method = RequestMethod.POST) public String postTest1(){ return \"POST请求\"; } @RequestMapping(value = \"/postTest2\",method = RequestMethod.POST) public String postTest2(String username,String password){ System.out.println(\"username:\"+username); System.out.println(\"password:\"+password); return \"POST请求\"; } @RequestMapping(value = \"/postTest3\",method = RequestMethod.POST) public String postTest3(User user){ System.out.println(user); return \"POST请求3\"; } @RequestMapping(value = \"/postTest4\",method = RequestMethod.POST) public String postTest4(@RequestBody User user){ System.out.println(user); return \"post请求\"; } @GetMapping(\"/test/**\") public String test(){ return \"通配符请求\"; } } ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:2:4","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"APIPOST 可以模拟post请求 （本来需要通过专门的前端程序或者表单，这里可以通过APIPOST进行前端调试） （在地址栏里面发送的是get请求，不能直接/postTest（post请求的方法），会有405（4开头一般是浏览器的问题）） JSON类型需要使用{}传递 如果需要接收JSON类型的数据需要加一个单独的注解 @RequestBody 需要注意类型与参数名都要对的上 通配符（了解即可）/test/**,意味着/test/a/b/c都行。/test/*意味着只能/test/abcc。 ","date":"2023-12-01","objectID":"/posts/springbootp3.html/:3:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"SpringBoot快速上手 ","date":"2023-11-30","objectID":"/posts/springbootp2.html/:1:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Springboot的介绍 Springboot旨在简化SSM（Spring\\SpringMVC\\Mybatis）的配置过程 ","date":"2023-11-30","objectID":"/posts/springbootp2.html/:1:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Springboot的特点 之所以能够简化操作，Springboot做到了： 约定优于配置” ，用大量的默认配置代替手动配置的过程 使用内嵌的Tomcat，用户无需再手动打包war文件让服务器使用 定制Staters启动器，简化了Maven配置（帮你配置好了,简化以前可能需要写几十个依赖的情况,现在写一两个即可） 使用纯Java配置 后续维护时，Springboot提供了各种监控检测功能 （如若需要开发复杂项目还需继续学习Spring【不过Springboot完全够用了，除非是接口几千个的大项目，可能要考虑到后续并发量之类的问题，Springboot作为一个比较单体的东西，可能确实是不太应付得来】） ","date":"2023-11-30","objectID":"/posts/springbootp2.html/:1:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建Springboot应用 (IDEA2020.3) 创建 Group处一般输入公司域名 Artifact处输入项目名称 SDK:1.8 Java version:8【SDK17选择Java 17也无大碍】 Web→Spring Web 选择存放位置 右下角会显示下载依赖的进度条，如果持续太久了可能是下面的配置路径出了问题（需要修改过阿里云镜像，要不然就很慢） Settings→Build,Execution,Deployment→Build Tools→Maven 基本结构（基于maven） 代码位于src下的java目录 resources下放置一些资源（系统会自动放一些文件夹和配置目录） static放置网站的静态资源 templates放置网站的html之类的模板 application.properties为重要的配置文件（但springboot无需配置） test为java的测试 pom.xml parent标签，可以认为是一个副级的项目，我们现在就是依赖于这个项目，不需要多做配置 dependencies，一些依赖包 main→java→com.example.xxx是主包，后续我们要写什么都需要放进主包 启动程序为主包下的xxxApplication类 操作 在主包下创建controller包，创建xxxController类 在类中做**@RestController**标记以让此类变为控制器，可以接收客户端的请求 具体如何接收需要在类中加入public方法，返回类型为String： pubilic String xxx(){ return \"hello world\";} 期望为浏览器访问后端时，能够看到此字符串 加入一个注解：@GetMapping(\"/xxx\") 效果为浏览器可以发送http里的get请求来访问xxx()方法，具体访问方法时需要明确的链接地址：/xxx 浏览器如何访问？浏览器会固定使用\"http\"的协议，后加一个域名，再往后是具体路径/path:http://localhost:8080/path,上面的/xxx就是此处的路径，这样就可以访问刚刚写的方法（默认localhost:80，但80是可以省略的，一般访问本地主机就写成localhost，但是Tomcat访问的是8080端口，所以需要写成localhost:8080)。 全部代码如下 创建Controller包，包下创建HelloController类 @RestController public class HelloController { // →地址栏可以通过问号传参http://localhost:8080/hello?nickname=zhangsan // ↓等价于@RequestMapping(value = \"/hello\",method= RequestMethod.GET) @GetMapping(\"/hello\") public String hello(String nickname,String phone){ System.out.println(phone); return \"HELLO,WORLD(｡･∀･)ﾉﾞ！\"+nickname; } } 启动 找到xxxApplication启动类，启动程序 会在启动台里看见Springboot的标志 在浏览器输入localhost:8080/xxx 修改一定要重启项目（可以通过热部署解决） ","date":"2023-11-30","objectID":"/posts/springbootp2.html/:1:3","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2.html/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"开发环境热部署 在pom.xml中加入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e 点击右上角的按钮，下载依赖 在application.properties配置devtools spring.devtools.restart.enabled=true spring.devtools.restart.additional-paths=src/main/java 打开Settings页面，在左边的菜单栏依次找到Build,Execution,Deployment一Compile，勾选 Build project automatically 按Ctrl+Shift+Alt+/快捷键调出Maintenance页面，单击Registry，勾选 compiler,automake.allow,when.app.running (IDEA2021版本的设置在Settings→Advanced Settings→Comiler里面) ","date":"2023-11-30","objectID":"/posts/springbootp2.html/:2:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2.html/"}]