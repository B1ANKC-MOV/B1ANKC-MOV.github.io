[{"categories":["SpringBoot+Vue全栈开发"],"content":"\r注意\r在部署前后端项目之前，首先需要保证nginx服务是开启的： systemctl start nginx #开启nginx服务 接着将服务器的公网IP地址粘到浏览器中，如果能看见如下界面，说明nginx可以访问。(这个访问的是80端口，需要保证安全组的80端口是开启的) nginx成功界面\r","date":"2024-01-15","objectID":"/posts/springbootvuep20/:0:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"项目部署 ","date":"2024-01-15","objectID":"/posts/springbootvuep20/:1:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"部署Vue项目 打包Vue项目 进入到Vue项目目录，执行 npm run build 将生成的dist目录上传至服务器 /usr/vue/dist 配置nginx 进入到/etc/nginx/conf.d目录，创建vue.conf文件，内容如下 server { listen 80; server_name locahost; location / { root /usr/app/dist; index index.html; } } 使配置生效 nginx -s reload ","date":"2024-01-15","objectID":"/posts/springbootvuep20/:1:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"打包Java程序 双击package，会自动打包在项目路径文件夹的/target文件夹下 因为springboot有内置tomcat容器，这点比较方便，省去了tomcat的部署。我们到时候直接可以直接把jar包扔到linux上。 nohup java -jar projectName-0.0.1-SNAPSHOT.jar \u003e logName.log 2\u003e\u00261 \u0026 ","date":"2024-01-15","objectID":"/posts/springbootvuep20/:1:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操(代码在前半部分都有) ","date":"2024-01-15","objectID":"/posts/springbootvuep20/:2:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"前端vue项目部署 打包简单的vue项目 以全栈学习·第三方组件（element-ui）里的vue项目为例。 打开项目，在终端服务器输入 npm run build 将代码进行打包，打包下来的文件会放在dist目录下的index.html(只有一行是因为做了压缩)，最后需要做的就是把dist目录放在服务器上进行访问。 打包成功的终端界面\r打包复杂的vue项目 以全栈学习·vue-element-admin里的vue项目为例。 修改.env.production文件里面的BASE_API为服务器的公网IP地址并打包文件： 修改API\u0026终端打包\r上传vue项目dist文件 先创建一个目录放上传的项目文件 创建文件夹\r接着使用xftp将dist文件拖进服务器文件夹里 传输dist文件\r配置nginx读取dist文件 进入到/etc/nginx/conf.d目录，创建vue.conf文件 创建.conf文件\r编辑.conf文件\r其中，localhost处是自己的域名，location里面的index.html是自己的首页。 接着输入指令加载配置，然后再去访问公网IP，页面就会变化(此时是登录不进去的，还没连上后台) 使配置生效\r页面内容变化\r","date":"2024-01-15","objectID":"/posts/springbootvuep20/:2:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"后端springboot项目部署 新建数据库 注意\r如果创建不了数据库，记得重新开一下服务器的数据库。 启动数据库\r如果执行sql文件导入表时出现问题，Navicat可以看这个解决方法：Navicat报错Unknown collation: ‘utf8mb4_0900_ai_ci’_ 数据库工具上创建和依赖文件同名的数据库 数据库\r打包发送文件 点Maven里面的package打包文件，生成jar包，并上传到服务器的/usr/app目录下 打包成功\r传输jar包\r执行jar包 在服务器终端执行命令，加载jar包(记得修改jar包的名字变成自己的) 启动java项目，查看日志文件\r注意\r如果日志显示 nohup: ignoring input no main manifest attribute, in projectName-0.0.1-SNAPSHOT.jar 把pom.xml文件里面的这个地方注释掉，再上传启动一次 jar包找不到启动类解决方法\r(可害死我了，找了半天发现这里居然有个默认跳过的代码！) 启动成功的日志\r[笔者部署完之后无法成功登录老是neterror不知道什么情况，改天再解决一下] ","date":"2024-01-15","objectID":"/posts/springbootvuep20/:2:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境部署(阿里云服务器部署项目)","uri":"/posts/springbootvuep20/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"云端环境准备 注意\r以下部署基于Centos7 系统环境\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:1:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"安装MySQL 卸载Centos7自带mariadb # 查找 rpm -qa|grep mariadb # mariadb-libs-5.5.52-1.el7.x86_64 # 卸载 rpm -e mariadb-libs-5.5.52-1.el7.x86_64 --nodeps 解压mysql # 创建mysql安装包存放点 mkdir /usr/server/mysql # 解压 tar xvf mysql-5.7.34-1.el7.x86_64.rpm-bundle.tar 执行安装 # 切换到安装目录 cd /usr/server/mysql/ yum -y install libaio yum -y install libncurses* yum -y install perl perl-devel # 安装 rpm -ivh mysql-community-common-5.7.34-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.34-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.34-1.el7.x86_64.rpm 启动Mysql #启动mysql systemctl start mysqld.service #查看生成的临时root密码 cat /var/log/mysqld.log | grep password mysql初始随机密码\r修改初始的随机密码 # 登录mysql mysql -u root -p Enter password: #输入在日志中生成的临时密码 # 更新root密码 设置为root set global validate_password_policy=0; set global validate_password_length=1; set password=password('root'); 授予远程连接权限 grant all privileges on *.* to 'root' @'%' identified by 'root'; # 刷新 flush privileges; 控制命令 #mysql的启动和关闭 状态查看 systemctl stop mysqld systemctl status mysqld systemctl start mysqld #建议设置为开机自启动服务 systemctl enable mysqld #查看是否已经设置自启动成功 systemctl list-unit-files | grep mysqld 关闭防火墙 firewall-cmd --state #查看防火墙状态 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:1:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"安装nginx 安装命令 yum install epel-release #更新样本源 yum update yum -y install nginx nginx命令 systemctl start nginx #开启nginx服务 systemctl stop nginx #停止nginx服务 systemctl restart nginx #重启nginx服务 ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:1:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置JDK 官网下载 下载JDK，登录官网下载所需版本的JDK，版本为JDK 1.8 https://www.oracle.com/java/technologies/downloads/#java8 JDK1.8\r解压 tar -zvxf jdk-8u131-linux-x64.tar.gz 编辑 /etc/profile 文件 vi /etc/profile # 文件末尾增加 export JAVA_HOME=/usr/server/jdk1.8.0_391 export PATH=${JAVA_HOME}/bin:$PATH 执行source命令，使配置立即生效 source /etc/profile 检查是否安装成功 java -version ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:1:3","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操(代码在前半部分都有) ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"切换目录 打开XShell连接服务器后是在root目录下，切换到usr目录。 ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建文件 创建文件夹server ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"上传文件 注意\r文件传输使用Xftp7，下载安装很简单，一路next就行了，此文不再赘述，官网： https://www.xshell.com/zh/free-for-home-school/ 下载完Xftp7之后，点击XShell里面的新建文件传输。 把下载好的java压缩包、mysql压缩包和nginx压缩包(nginx可以先不下)传输过去。 mysql下载版本选择\rnginx下载版本选择\r拖拽压缩包到服务器窗口进行传输\r传输完成后再次查询目录下文件，应该能查到文件了。 ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:3","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"卸载mariadb 查询系统中是否已有mariadb，如果有，就卸掉。 查找mariadb\r卸载mariadb\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:4","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"解压mysql 创建mysql安装包存放文件夹并解压。 创建mysql文件夹\r解压mysql\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:5","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"安装mysql 先输入yum指令安装依赖 安装mysql的依赖(环境)\r安装mysql的依赖(环境)\r再输入安装指令进行安装(没有安装依赖会报错) 注意\r需要根据前面安装的版本修改一下指令里面的版本，这里如果不是阿里云服务器而是自己的虚拟机，需要确定已经联网。\r安装mysql\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:6","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"启动mysql 输入指令启动mysql，使用cat指令拿到临时密码，随后进入root修改密码 启动mysql并修改密码\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:7","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"开启mysql远程连接 开启远程连接权限，并设置开机自启。 远程连接\u0026开启自启\r注意\r这里如果不是阿里云服务器而是自己的虚拟机，需要再关一下防火墙，阿里云自带的防火墙在安全组里面已经关了，只需要保证把3306的端口打开就行。\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:8","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"安装nginx 先更新一下样本源 更新源\r注意\r也可以使用之前自己下载的安装包，但如果这里是更新样本源的话，刚刚上传的安装包也就没什么用了，可以不上传。\r接着更新一下 yum更新\r注意\r笔者第一次更新好像非常的慢，一直卡在一个Installing五分钟，就直接中止当前任务再更新一次了。终止快捷键是ctrl+z，然后再输入 rm -f /var/run/yum.pid 强行把任务断掉，要不然会一直等进程释放，接着再输入更新命令即可。 解决掉问题之后的yum更新\r最后使用命令安装 安装nignx\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:9","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"启动nginx 输入指令启动nginx 启动启动启动全部启动.jpg\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:10","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置JDK 输入指令解压JDK文件到server目录 解压JDK\r再进入 /etc/profile 文件，在文件末尾添加两行代码。 打开文件\r编辑文件\r注意\r这里一定要注意把path里面的文件路径改成你自己安装的文件路径，按i进入编辑状态，把代码粘进去之后，Esc进入command状态，然后输入:wq保存并退出。\r最后输入指令，读一下配置，试一下java命令能不能用 配置\u0026测试\r","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:11","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建mysql连接服务器 笔者是在Navicat里面创建mysql连接，主机是服务器的公网IP地址，密码和用户名是刚刚设配置数据库的时候设置的密码和用户名。 创建数据库连接\r注意\r如果这里连接失败了，需要检查前面mysql的远程连接有没有开启，以及安全组里面3306的端口有没有开启。\r由于篇幅原因，打包部署项目到服务器的部分放在下一篇 ","date":"2024-01-12","objectID":"/posts/springbootvuep19/:2:12","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·Springboot+Vue云端环境配置(阿里云服务器环境配置)","uri":"/posts/springbootvuep19/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"云服务器介绍 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:1:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"云服务器概念 云服务器(Elastic Compute Service, ECS)是一种简单高效、安全可靠、处理能力可弹性伸缩的计算服务。其管理方式比物理服务器更简单高效。 用户无需提前购买硬件，即可迅速创建或释放任意多台云服务器。 物理服务器vs云服务器\r","date":"2024-01-11","objectID":"/posts/springbootvuep18/:1:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"云服务器的特点 ECS的最重要的特点是弹性，支持垂直和水平扩展两种能力。 ECS的特点\rECS一般提供自动宕机迁移、数据备份和回滚、系统性能报警等功能，稳定性更高 传统服务器的缺点\r","date":"2024-01-11","objectID":"/posts/springbootvuep18/:1:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"阿里云ECS的使用 注意\r服务器部署仅适合此系列项目演示使用，首次注册倾向于使用支付宝扫码，账户需要预存100￥才能购买服务器。\r","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"进入官网 https://www.aliyun.com/ ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"点击菜单栏中的[产品]，选择[计算]分类，选择云服务器ECS ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"选择按量付费，地域随意，网络及可用区随意 注意\r此为旧版购买网页，新版购买方式可以查看官方文档： https://help.aliyun.com/zh/ecs/getting-started/create-and-manage-an-ecs-instance-by-using-the-ecs-console ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:3","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"选择架构[X86计算]，在下拉列表里面选择[共享型]，vCPU选1核及以上的，内存选1GiB及以上的 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:4","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"选择[公共镜像]里的[CentOS]，在下拉列表里面选择7.6版 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:5","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"选择ESSD云盘，容量默认40GiB，可以自行添加容量与数据盘 注意\r目前默认的高效云盘要比ESSD云盘差些。\r","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:6","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"网络配置全部默认，公网IP处勾选[分配公网IPv4地址]，[按使用流量]，带宽峰值默认为[5Mbps] ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:7","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"网卡交换机选择默认 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:8","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"选择[自定义密码]，设置密码，实例名称等默认，点击[确认订单] ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:9","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"可以在使用时限里面勾选[设置自动释放服务时间]，设置个一两天的节点，要不然会一直扣钱的。 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:2:10","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"远程链接（XShell） ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:0","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"进入云服务器ECS管理台 https://ecs.console.aliyun.com/server/region ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:1","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"查看安全组，点进安全组 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:2","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"将入方向的22端口开启 注意\r如果后续在服务器里面安装了数据库，或是要提供Web服务，那么对应的80端口和443端口也要打开。MySQL则需要打开3306端口。\r","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:3","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"使用XShell远程连接服务器 信息\rXShell安装比较简单，一直下一步即可，这里就不再详写了，免费版官网地址： https://www.xshell.com/zh/free-for-home-school/ 打开XShell后新建会话 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:4","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"输入服务器公网IP ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:5","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"连接服务器，输入服务器账号密码 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:6","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"连接服务器，不想每次都输入密码的可以点击接受并保存主机密钥 ","date":"2024-01-11","objectID":"/posts/springbootvuep18/:3:7","tags":["个人学习","后端","前端","服务器"],"title":"全栈学习·阿里云服务器的配置\u0026搭建\u0026购买\u0026使用","uri":"/posts/springbootvuep18/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"前端项目 下载地址： https://github.com/B1ANKC-MOV/SpringVue/tree/f9761a2732d92e2bb82e4d21e568613f859c489a/P17/projectName Attention\r由于第二次演示的前端项目只是根据不同组件对vue-admin-template进行改造，这里就不再放出了。\r","date":"2024-01-11","objectID":"/posts/springbootvuep17/:1:0","tags":["个人学习","后端","前端"],"title":"全栈学习·SpringBoot+vue-element-template(前后端集成)","uri":"/posts/springbootvuep17/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"后端项目 下载地址： https://github.com/B1ANKC-MOV/SpringVue/tree/f9761a2732d92e2bb82e4d21e568613f859c489a/P17/vue-admin-template Attention\r这里的代码并不包括【SpringBoot+Vue全栈开发[17:00]】 的Brand等部分。\r","date":"2024-01-11","objectID":"/posts/springbootvuep17/:2:0","tags":["个人学习","后端","前端"],"title":"全栈学习·SpringBoot+vue-element-template(前后端集成)","uri":"/posts/springbootvuep17/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Session认证 互联网服务离不开用户认证。一般流程是下面这样： 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 session认证流程\rsession 认证的方式应用非常普遍，但也存在一些问题，扩展性不好，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session，针对此种问题一般有两种方案： 一种解决方案是session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。 一种方案是服务器不再保存 session 数据，所有数据都保存在客户端，每次请求都发回服务器。Token认证就是这种方案的一个代表。 ","date":"2024-01-11","objectID":"/posts/springbootp16/:1:0","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Token认证 Token 是在服务端产生的一串字符串,是客户端访问资源接口（API）时所需要的资源凭证，流程如下： 客户端使用用户名跟密码请求登录，服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 token认证流程\r","date":"2024-01-11","objectID":"/posts/springbootp16/:2:0","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Token认证的特点 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放token 数据。 用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 token 完全由应用管理，所以它可以避开同源策略 ","date":"2024-01-11","objectID":"/posts/springbootp16/:2:1","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"JWT的使用 ","date":"2024-01-11","objectID":"/posts/springbootp16/:3:0","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"JWT介绍 JSON Web Token（简称 JWT）是一个token的具体实现方式，是目前最流行的跨域认证解决方案。 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，具体如下： { \"姓名\":\"张三\", \"角色\":\"管理员\", \"到期时间\":\"2018年7月1日0点0分\" } 用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。 为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 ","date":"2024-01-11","objectID":"/posts/springbootp16/:3:1","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"JWT的组成 JWT 的由三个部分组成，依次如下： Header（头部） Payload（负载） Signature（签名） 三部分最终组合为完整的字符串，中间使用 . 分隔，如下： Header.Payload.Signature JWT\rHeader Header 部分是一个 JSON 对象，描述 JWT 的元数据 { \"alg\":\"HS256\", \"typ\":\"JWT\" } alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成HS256） typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT 最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串 Payload Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。这个 JSON 对象也要使用 Base64URL 算法转成字符串。 iss(issuer): exp(expiration time): sub(subject): aud(audience): nbf(Not Before): iat(Issued At): jti(JWT ID): 注意\r注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\rSignature Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户 然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 HMACSHA256( base64UrlEncode(header)+\".\"+ base64UrlEncode(payload), secret) ","date":"2024-01-11","objectID":"/posts/springbootp16/:3:2","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"JWT返回字符串 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。 JWT返回用户的字符串\r客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在localStorage。 客户端每次与服务器通信，都要带上这个 JWT，可以把它放在 Cookie 里面自动发送，但是这样不能跨域。 更好的做法是放在 HTTP 请求的头信息Authorization字段里面，单独发送。 ","date":"2024-01-11","objectID":"/posts/springbootp16/:3:3","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"JWT的实现 加入依赖 \u003cdependency\u003e \u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e \u003cartifactId\u003ejjwt\u003c/artifactId\u003e \u003cversion\u003e0.9.1\u003c/version\u003e \u003c/dependency\u003e 生成Token // 7天过期 private static long expire = 604800; // 32位密钥 private static String secret =\"abcdfghiabcdfghiabcdfghiabcdfghi\"; // 生成token public static String generateToken(String username){ Date now = new Date(); Date expiration = new Date(now.getTime() + 1000 * expire); return Jwts.builder() .setHeaderParam(\"type\",\"JWT\") .setSubject(username) .setIssuedAt(now) .setExpiration(expiration) .signWith(SignatureAlgorithm.HS512,secret) .compact(); } 解析Token // 解析token public static Claims getClaimsByToken(String token){ return Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); } ","date":"2024-01-11","objectID":"/posts/springbootp16/:3:4","tags":["个人学习","后端"],"title":"全栈学习·JWT跨域认证","uri":"/posts/springbootp16/"},{"categories":["工作学习"],"content":"创建主表实体类 首先创建一个entity包下的主表实体类，这里命名为User。 代码如下： /** * 主表实体类 * @author VVulpes * @CreateDate 2023-12-28 */ @Data // Mybatis规定了如果类名与表名一致，会自动找寻对应的数据表，如果不一致，需要加一个注解告诉它对应的表格名称 @TableName(\"t_user\") public class User { // 这个注解告诉了Mybatis字段id为主键，且自增，使得代码中能拿到主键的值 @TableId(type = IdType.AUTO) private Integer id; private String username; // 该字段为与子表相连的外键，需要注意的是，使用Mybatis写SQL语句时，类中的属性名一定要和表中的字段名相同，如果不同，可以使用@TableField(\"字段名\")进行注解 private Integer user_id; // 为子表数据创建虚拟字段，这里用来存放JSON格式数据中传入的子表内容，后面再通过控制器一一插入子表字段 @TableField(exist = false) private List\u003cOrder\u003e orders; } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:1:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["工作学习"],"content":"创建子表实体类 类似地，在entity包下创建子表实体类Order。 代码如下： /** * 子表实体类 * @author VVulpes * @CreateDate 2023-12-28 */ @Data @TableName(\"t_order\") public class Order { @TableId(type = IdType.AUTO) private Integer id; private Long order_id; private String order_time; private Float order_val; private Integer user_id; } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:2:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["工作学习"],"content":"创建主表Mapper接口 接下来，在mapper包下为主表创建一个接口（interfac）类。 代码如下： /** * 主表Mapper接口 * @author VVulpes * @CreateDate 2023-12-28 */ @Mapper // 由于Mybatis内置了很多的语句，已经帮我们写好了增删改查等操作，我们这里不需要写任何方法，只需要继承Mybatis的BaseMapper，接着在控制器中调用方法即可 public interface User extends BaseMapper\u003cUser\u003e { } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:3:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["工作学习"],"content":"创建子表Mapper接口 类似地，在mapper包下创建子表Mapper接口。 代码如下： /** * 子表Mapper接口 * @author VVulpes * @CreateDate 2023-12-28 */ @Mapper public interface Order extends BaseMapper\u003cOrder\u003e { } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:4:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["工作学习"],"content":"创建控制器类 接下来就到了重头戏和主要实现部分——控制器 首先在controller包下创建一个控制器类，这里命名为UserOrderController。 具体代码如下： /** * 用户订单数据存储接口 * @author VVulpes * @CreateDate 2023-12-28 */ @RestController public class UserOrderController { // 向接口类中注入字段，否则为空 @Autowired private UserMapper userMapper; @Autowired private OrderMapper orderMapper; // 由于传入数据为JSON格式，需要加一个@RequestBody注解 @PostMapping(\"/insertuserorder\") public GeneralResponse save(@RequestBody User user){ // 插入数据，i代表着插入的数据条数 int i= userMapper.insert(user); List\u003cOrder\u003e orders = User.getOrders(); if(orders != null){ for(Order order : orders){ order.setUser_id(User.getUser_id()); orderMapper.insert(order); } } if(i\u003e0){ return \"插入成功\"; }else { return \"插入失败\"; } } } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:5:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["工作学习"],"content":"演示JSON数据 格式如下： { \"user_name\":\"用户06\", \"user_id\":7899, \"orders\":[ { \"order_id\":6, \"order_time\":\"2023-01-03 11:35:56\", \"order_val\":46, \"user_id\":\"\" } ] } ","date":"2024-01-08","objectID":"/posts/mybatisplusmysql/:6:0","tags":["Java","MySQL","Mybatis","数据库","后端","工作学习"],"title":"[Java] Mybatis向Mysql插入主副表JSON数据","uri":"/posts/mybatisplusmysql/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"vue-element-admin介绍 vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现 内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件 可以快速搭建企业级中后台产品原型 地址： https://panjiachen.github.io/vue-element-admin-site/zh/guide/ ","date":"2024-01-08","objectID":"/posts/vuep15/:1:0","tags":["个人学习","前端"],"title":"全栈学习·vue-element-admin","uri":"/posts/vuep15/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"安装与使用 克隆项目 git clone https://github.com/PanJiaChen/vue-elementadmin.git 进入项目目录 cd vue-element-admin 安装依赖 npm install 使用淘宝镜像 npm install --registry=https://registry.npm.taobao.org 本地开发启动项目 npm run dev ","date":"2024-01-08","objectID":"/posts/vuep15/:2:0","tags":["个人学习","前端"],"title":"全栈学习·vue-element-admin","uri":"/posts/vuep15/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"注意事项 若依赖安装不成功，很大概率是node-sass安装失败。 node-sass因为其历史原因，安装时极易失败，同时node-sass依赖了Python环境，因此电脑上需要安装配置Python2 建议直接使用课程提供的包含有依赖包的项目，简化学习曲线 ","date":"2024-01-08","objectID":"/posts/vuep15/:2:1","tags":["个人学习","前端"],"title":"全栈学习·vue-element-admin","uri":"/posts/vuep15/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"项目构建过程 项目提供了完成的构建过程，适合前端技术的学习： https://juejin.cn/post/6844903476661583880 ","date":"2024-01-08","objectID":"/posts/vuep15/:2:2","tags":["个人学习","前端"],"title":"全栈学习·vue-element-admin","uri":"/posts/vuep15/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"mockjs介绍 Mock.js 是一款前端开发中拦截Ajax请求再生成随机数据响应的工具，可以用来模拟服务器响应，优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型 前后端分离 开发无侵入（不需要修改既有代码，就可以拦截Ajax请求，返回模拟的响应数据） 数据类型丰富（支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等） 增加单元测试的真实性（通过随机数据，模拟各种场景） 用法简单、符合直接的接口 方便扩展（支持扩展更多数据类型，支持自定义函数和正则） 安装： npm install mockjs ","date":"2024-01-08","objectID":"/posts/vuep14/:1:0","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"基本使用 在项目中创建mock目录，新建index.js文件 // 引入mockjs import Mock from 'mockjs' // 使用mockjs模拟数据 Mock.mock('/product/search',{ \"ret\":0, \"data\": { \"mtime\":\"@datetime\",// 随机生成日期时间 \"score|1-800\":1,// 随机生成1-800的数字 \"rank|1-100\":1,// 随机生成1-100的数字 \"stars|1-5\":1,// 随机生成1-5的数字 \"nickname\":\"@cname\",// 随机生成中文名字 // 生成图片 \"img\":\"@image('200x100','#ffcc33','#FFF','png','Fast Mock')\" } }); main.js里面引入 import './mock' 组件（xxx.vue文件）中调用mock.js中模拟的数据接口，这时返回的response就是mock.js中用Mock.mock(‘url’,data）中设置的data import axios from 'axios' export default { mounted:function(){ axios.get(\"/product/search\").then(res =\u003e { console.log(res) }) } } 注意，如果get请求带参数，会以?a=b\u0026c=d形式拼接到url上，这时mock请把接口url写为正则匹配Mock.mock(RegExp(API_URL + \".*\"))，否则匹配不到就报错，如： import axios from 'axios' export default { mounted:function(){ // /product/search?id=2 axios.get(\"/product/search\",{params:{id:2}}).then(res =\u003e { console.log(res) }) } } 在url后面加上.* mockjs.mock(RegExp(\"/product/search\" + \".*\"),'get',option =\u003e{ console.log(option.url)// 请求的url console.log(option.body)// body为post请求参数 return{ status:200, message:\"获取数据成功\" } }) ","date":"2024-01-08","objectID":"/posts/vuep14/:2:0","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"核心方法 Mock.mock( rurl?, rtype?, template|function( options ) ) 这是mock的核心方法，根据数据模板生成模拟数据。 rurl，可选。 表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如：正则+变量写法→RegExp(API_URL.LOGIN + \".*\"),正则写法→/\\/domain\\/list\\.json/，字符串写法→'/domian/list.json'。 rtype，可选。 表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等 template，可选。 表示数据模板，可以是对象或字符串。例如{'data|1-10':[{}]}、'@EMAIL'。 function，可选。 表示用于生成响应数据的函数。 options 指向本次请求的Ajax选项集，含有url、type、body三个属性。 ","date":"2024-01-08","objectID":"/posts/vuep14/:3:0","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"具体使用 Mock.mock(template):根据数据模板生成模拟数据 Mock.mock(rurl,template):记录数据模板，当拦截到匹配rurl的Ajax请求时，将根据数据模板template生成模拟数据，并作为响应数据返回。 Mock.mock(rurl,function(options)):记录用于生成响应数据的函数。当拦截到匹配rurl的Ajax请求时，函数function(options)将被执行，并把执行结果作为响应数据返回。 Mock.mock(rurl,rtype,template):记录数据模板。当拦截到匹配rurl和rtype的Ajax请求时，将根据数据模板template生成模拟数据，并作为记录返回。 Mock.mock(rurl,rtype,function(options)):记录用于生成响应数据的函数，当拦截到匹配rurl和rtype的Ajax请求时，函数function(options)将被执行，并把执行结果作为响应数据返回。 ","date":"2024-01-08","objectID":"/posts/vuep14/:3:1","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"设置延时请求到数据 不设置延时很有可能遇到坑，这里需要留意，因为真实的请求是需要时间的，mock不设置延时则是马上拿到数据返回，这两个情况不同可能导致在接口联调时出现问题，所以最好要先设置延时请求到数据。 // 延时400ms请求到数据 Mock.setup({ timeout:400 }) // 延时200-600毫秒请求到数据 Mock.setup({ timeout:'200-600' }) ","date":"2024-01-08","objectID":"/posts/vuep14/:3:2","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"数据生成规则 ","date":"2024-01-08","objectID":"/posts/vuep14/:4:0","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"数据模板DTD mock的语法规范包含两层规范: 数据模板 （DTD） 数据占位符 （DPD） 基本语法 数据模板中的每个属性由 3 部分构成：属性名name、生成规则rule、属性值value： 'name|rule':value 属性名和生成规则之间用竖线 | 分隔，生成规则是可选的，有 7 种格式： 生成规则的含义需要依赖属性值的类型才能确定 属性值中可以含有@占位符 属性值还指定了最终值的初始值和类型 'name|min-max':value 'name|count':value 'name|min-max,dmin-dmax':value 'name|min-max.dcount':value 'name|count.dmin-dmax':value 'name|count.dcount':value 'name|+step':value 生成规则和示例 属性值是字符串String // 通过重复string生成一个字符串，重复次数大于等于min，小于等于max 'name|min-max':string // 通过重复string生成一个字符串，重复次数等于count 'name|count':string var data = Mock.mock({ 'name1|1-3':'a', //重复生成1到3个a(随机) 'name2|2':'b' //生成bb }) 属性值是数字Number // 属性值自动加1，初始值为number 'name|+1':number // 生成一个大于等于min、小于等于max的整数，属性值number只是用来确定类型 'name|min-max':number // 生成一个浮点数，整数部分大于等于min、小于等于max，小数部分保留dmin到dmax位 'name|min-max.dmin-dmax':number Mock.mock({ 'number1|1-100.1-10':1, 'number2|123.1-10':1, 'number3|123.3':1, 'number4|123.10':1.123, }) //结果： { \"number1\":12.92, \"number2\":123.51, \"number3\":123.777, \"number4\":123.1231091814, } var data = Mock.mock({ 'name1|+1':4, //生成4，如果循环每次加1 'name2|1-7':2, //生成一个数字，1到7之间 'name3|1-4.5-8':1, //生成一个小数，整数部分1到4，小数部分5到8位，数字1只是为了确定类型 }) 属性值是布尔型Boolean // 随机生成一个布尔值，值为true的概率是1/2，值为false的概率同样是1/2 'name|1':boolean // 随机生成一个布尔值，值为value的概率是min/(min+max)，值为!value的概率是max/(min+max) 'name|min-max':value var data = Mock.mock({ 'name|1':true, // 生成一个布尔值，各一半 'name1|1-3':true //1/4是true，3/4是false }) 属性值是对象Object // 从属性值object中随机选取count个属性 'name|count':object // 从属性值object中随机选取min到max个属性 'name|min-max':object var obj = { a:1, b:2, c:3, d:4 } var data = Mock.mock({ 'name|1-3':obj, // 随机从obj中寻找到1到3个属性，新对象 'name|2':obj // 随机从obj中找到两个属性，新对象 }) 属性值是数组Array // 从属性值array中随机选取1个元素，作为最终值 'name|1':array // 从属性值array中顺序选取1个元素，作为最终值 'name|+1':array // 通过重复属性值array生成一个新数组，重复次数大于等于min，小于等于max 'name|min-max':array // 通过重复属性值array生成一个数组，重复次数为count 'name|count':array Mock.mock({ // 通过重复属性值array生成一个新数组，重复次数为1-3次 \"favorite_games|1-3\":[3,5,4,6,23,28,42,45], }); 属性值是函数Function // 执行函数function，取其返回值作为最终的属性值，函数的上下文属性'name'所在的对象 'name':function var fun = function(x){ return x+10; } var data = Mock.mock({ 'name':fun(10) // 返回函数的返回值20 }) 属性值是正则表达式RegExp // 根据正则表达式regexp反向生成可以匹配它的字符串，用于生成自定义格式的字符串 'name':regexp Mock.mock({ 'regexp1':/[a-z][A-Z][0-9]/, 'regexp2':/\\w\\W\\s\\S\\d\\D/, 'regexp3':/\\d{S,10}/ }) // =\u003e { \"regexp1\":\"pJ7\", \"regexp2\":\"F)\\fp1G\", \"regexp3\":\"561659409\" } ","date":"2024-01-08","objectID":"/posts/vuep14/:4:1","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"数据占位符DPD 占位符只是在属性值字符串中占个位置，并不出现在最终的属性值中 占位符的格式为: @占位符 @占位符(参数[,参数]) 关于占位符需要知道以下几点 用@标识符标识后面的字符串是占位符 占位符引用的是Mock.Random中的方法 可以通过Mock.Random.extend()来扩展自定义占位符 占位符也可以引用数据模板中的属性 占位符会优先引用数据模板中的属性 占位符支持相对路径和绝对路径 // 引入mockjs import Mock from 'mockjs' // 使用mockjs模拟数据 Mock.mock('/api/msdk/proxy/query_common_credit',{ \"ret\":0, \"data\": { \"mtime\":\"@datetime\",// 随机生成日期时间 \"score\":\"@natural(1,800)\",// 随机生成1-800的数字 \"rank\":\"@natural(1,100)\",// 随机生成1-100的数字 \"stars\":\"@natural(0,5)\",// 随机生成1-5的数字 \"nickname\":\"@cname\",// 随机生成中文名字 } }); ","date":"2024-01-08","objectID":"/posts/vuep14/:4:2","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"用例 基础随机内容的生成 { \"string|1-10\":\"=\", \"string2|3\":\"=\", \"number|+1\":0, \"number2|1-00.1-3\":1, \"boolean\":\"@boolean(1,2,true)\", \"name\":\"@cname\", \"firstname\":\"@cfirst\", \"int\":\"@integer(1,10)\", \"float\":\"@float(1,2,3,4)\", \"range\":\"@range(1,100,10)\", \"natural\":\"@natural(60,100)\", \"email\":\"@email\", \"ip\":\"@ip\", \"datatime\":\"@date('yy-MM-dd hh:mm:ss')\" // ...... } 列表数据 { \"code\":\"0000\", \"data\":{ \"pageNo\":\"@integer(1,100)\", \"totalRecord\":\"@integer(100,1000)\", \"pageSize\":10, \"list|10\":[{ \"id|+1\":1, \"name\":\"@cword(10)\", \"title\":\"@cword(20)\", \"descript\":\"@csentence(20,50)\", \"price\":\"@float(10,100,10,100)\" }] }, \"desc\":\"成功\" } 图片 mockjs可以生成任意大小，任意颜色块，且用文字填充内容的图片，使我们不用到处找图片资源就能轻松实现图片的模拟展示 { \"code\":\"0000\", \"data\":{ \"pageNo\":\"@integer(1,100)\", \"totalRecord\":\"@integer(100,1000)\", \"pageSize\":10, \"list|10\":[{ // 参数从左到右依次为，图片尺寸，背景色，前景色(及文字颜色)，图片格式，图片中间的填充文字内容 \"image\":\"@image('200x100','#ffcc33','#FFF','png','Fast Mock')\" }] }, \"desc\":\"成功\" } ","date":"2024-01-08","objectID":"/posts/vuep14/:4:3","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mock.Random Mock.Random是一个工具类，用于生成各种随机数据 Mock.Random的方法在数据模板中称为占位符，书写格式为@占位符(参数[,参数]) 用法示例： var Random = Mock.Random Random.email() // =\u003e\"n.clark@miller.io\" Mock.mock('@email') // =\u003e\"y.lee@lewis.org\" Mock.mock({email:'@email'}) // =\u003e{email:\"v.lewis@hall.gov\"} Mock.Random提供的完整方法(占位符)如下： Type Method Basic boolean,natural,integer,float,character,string,range,date,time,datetime,now Image image,dataImage Color color Text paragraph,sentence,word,title,cparagraph,csentence,cword,ctitle Name first,last,name,cfirst,clast,cname Web url,domain,email,ip,tId Address area,region Helper capitalize,upper,lower,pick,shuffle Miscellaneous guid,id Basic Random.boolean(min?max?current?) 随机生成布尔值 var bool1 = Random.boolean(); //true false各一半 var bool2 = Random.boolean(1,2，false) //1/3的可能性是false 2/3是true Random.natural(min?,max?) 随机生成一个自然数，什么叫自然数，就是大于等于0的 var natural1 = Random.natural(); //默认值最大为 9007199254740992 var natural2 = Random.natural(4); //随机出来的最小值是4 var natural3 = Random.natural(6,9); Random.Integer(min?,max?) 生成一个随机的整数，可以是负数。 var integer1 = Random.integer(); var integer2 = Random.integer(-10); //随机最小值是-10 var integer3 = Random.integer(-10,20); Random.float(min?,max?,dmin?,dmax?) 随机生成一个小数浮点数,四个参数分别为，整数部分最小值最大值，小数部分最小值最大值。 var float1 = Random.float(); var float2 = Random.float(3,8); var float3 = Random.float(1,3,5,7) Random.character(pool?) 随机生成一个字符,pool的值可以是： upper: 26个大写字母 lower: 26个小写字母 number: 0到9十个数字 sympol: “!@#$%^\u0026*()[]” var character1 = Random.character(); var character2 = Random.character('lower'); var character3 = Random.character('upper'); var character4 = Random.character('symbol'); Random.string(pool?,min?,max?) 随机生成一个字符串，pool的值同上边四个。 var str1 = Random.string(); //长度3到7位 var str2 = Random.string(5); //长度5位 var str3 = Random.string('lower',7); //长度7位，小写 var str4 = Random.string(4,6); //长度4到 var str5 = Random.string('新的字符串会从这里选择4到5位',4,6); //从第一个参数里选择4到5 位 Random.range(start?,stop,step?) 返回一个整型数组 start,可选，数组起始值，闭区间 stop,必选，数据结束值，开区间 step,可选，数据每一项间隔值 var range1 = Random.range(10); //[0,1,2,3,4,5,6,7,8,9] var range2 = Random.range(14,20); //[14,15,16,17,18,19] var range3 = Random.range(3,13,2); //[3,5,7,9,11] Random.date(format?) 返回一个随机日期的字符串 format的格式是‘yyyy-MM-dd’,可以随机组合 var date1 = Random.date(); var date2 = Random.date('yyyy-MM-dd'); var date3 = Random.date('y-M-d'); var date4 = Random.date('yy-MM-dd'); Random.time(format?) 返回时间字符串 format的格式是‘HH-mm-ss’ var time1 = Random.time(); var time2 = Random.time('HH-mm-ss'); var time3 = Random.time('J-m-s'); Random.datetime(format?) 上边两个的结合版 var dt1 = Random.datetime(); var dt2 = Random.datetime('yyyy-MM-dd HH-mm-ss'); Random.now(unit?,format?) 返回当前时间的字符串 Image 一般情况下，使用dataImage更好,因为更简单，但是如果要生成高度自定义的图片，则最好用image。另外，dataImage生成的是base64编码 Random.image(size?,background?,foreground?,format?text?) size 图片宽高，格式是’宽x高' background:图片的背景色，默认值#000000 foreground：图片的文字前景色，默认#FFFFFF format：图片的格式，默认’.png' text:图片上的默认文字，默认值为参数size 其中size的取值范围是 [ '300x250', '250x250', '240x400', '336x280', '180x150', '720x300', '468x60', '234x60', '88x31', '120x90', '120x60', '120x240', '125x125', '728x90', '160x600', '120x600', '300x600' ] 图片的格式可以选择.png 、 .gif 、 .jpg var image1 = Random.image(); var image2 = Random.image('128x90'); var image3 = Random.image('120x660','#ccc'); //前景色#ccc var image4 = Random.image('226x280','#eee','第三个参数是文字不是前景色'); var image5 = Random.image('66x31','#ddd','#123456','四个参数的时候第三个参数是前景 色'); var image6 = Random.image('240x400','#333','#1483dc','.gif','全部参数的情况下'); Random.dataImage(size?,text?) 返回一段base64编码，两个参数同上。 var di1 = Random.dataImage(); var di2 = Random.datImage('300x600'); var di3 = Random.dataImage('180x150','hahahaha'); Color Random.color() 有好几个相关的方法 var color = Random.color(); //格式'#rrggbb' var hex = Random.hex(); //好像和color没什么不同 var rgb = Random.rgb(); //生成格式如rgb(133,233,244) var rgba = Random.rgba(); //生成个事如rgba(111,222,233,0.5) var hsl = Random.hsl(); //生成格式(345,82,71) Text Random.paragraph(in?,max?,len?) 随机生成一段文本 var para1 = Random.paragraph(); //随机生成一短文本，范围3到7 var para2 = Random.p","date":"2024-01-08","objectID":"/posts/vuep14/:4:4","tags":["个人学习","前端"],"title":"全栈学习·前端数据模拟MockJS","uri":"/posts/vuep14/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vuex介绍 对于组件化开发来说，大型应用的状态往往跨越多个组件。在多层嵌套的父子组件之间传递状态已经十分麻烦，而Vue更是没有为兄弟组件提供直接共享数据的办法。 基于这个问题，许多框架提供了解决方案——使用全局的状态管理器，将所有分散的共享数据交由状态管理器保管，Vue也不例外。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理库，采用集中式存储管理应用的所有组件的状态。 简单的说，Vuex用于管理分散在Vue各个组件中的数据。 安装： npm install vuex@next 官网 https://v3.vuex.vuejs.org/zh/ ","date":"2024-01-08","objectID":"/posts/vuep13/:1:0","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"状态管理 每一个Vuex应用的核心都是一个store，与普通的全局对象不同的是，基于Vue数据与视图绑定的特点，当store中的状态发生变化时，与之绑定的视图也会被重新渲染。 store中的状态不允许被直接修改，改变store中的状态的唯一途径就是显式地提交（commit）mutation，这可以让我们方便地跟踪每一个状态的变化。 在大型复杂应用中，如果无法有效地跟踪到状态的变化，将会对理解和维护代码带来极大的困扰。 Vuex中有5个重要的概念：State、Getter、Mutation、Action、Module。 ","date":"2024-01-08","objectID":"/posts/vuep13/:2:0","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"State State用于维护所有应用层的状态，并确保应用只有唯一的数据源 // 创建一个新的store实例 const store = createStore({ state(){ return{ count:0 } }, mutations:{ increment(state){ state.count++ } } }) 在组件中，可以直接使用this.$store.state.count访问数据，也可以先用mapState辅助函数将其映射下来 // 在单独构建的版本中辅助函数为Vuex.mapState import{ mapState } from 'vuex' export default{ // ... computed:mapState({ // 箭头函数可使代码更简练 count:state =\u003e state.count, // 传字符串参数'count'等同于`state =\u003e state.count` countAlias:'count', // 为了能够使用`this`获取局部状态，必须使用常规函数 countPlusLocalState(state){ return state.count + this.localCount } }) } ","date":"2024-01-08","objectID":"/posts/vuep13/:2:1","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Getter Getter维护由State派生的一些状态，这些状态随着State状态的变化而变化 const store = createStore({ state:{ todos:[ {id:1,text:'...',done:true}, {id:2,text:'...',done:false} ] }, getters:{ doneTodos:(state)=\u003e{ return state.todos.filter(todo =\u003e todo.done) } } }) 在组件中，可以直接使用this.$store.getters.doneTodos，也可以先用mapGetters辅助函数将其映射下来，代码如下： import {mapGetters} from 'vuex' export default{ // ... computed:{ // 使用对象展开运算符将getter混入computed对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } } ","date":"2024-01-08","objectID":"/posts/vuep13/:2:2","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mutation Mutation提供修改State状态的方法 // 创建一个新的store实例 const store = createStore({ state(){ return{ const:0 } }, mutations:{ increment(state){ state.count++ } } }) 在组件中，可以直接使用store.commit来提交mutation methods:{ increment(){ this.$store.commit('increment') console.log(this.$store.state.count) } } 也可以先用mapMutation辅助函数将其映射下来 methods:{ ...mapMutations([ 'increment',// 将`this.increment()`映射为`this.$store.commit('increment')` // `mapMutations`也支持载荷: 'incrementBy' // 将`this.incrementBy(amount)`映射为`this.$store.commit('incrementBy',amount)` ]), } ","date":"2024-01-08","objectID":"/posts/vuep13/:2:3","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Action Action类似Mutation，不同在于： Action不能直接修改状态，只能通过提交mutation来修改，Action可以包含异步操作 const store = createStore({ state:{ count:0 }, mutations:{ increment(state){ state.count++ } }, actions:{ increment(context){ context.commit('increment') } } }) 在组件中，可以直接使用this.$store.dispatch(‘xxx’)分发 action，或者使用mapActions辅助函数先将其映射下来 // ... methods:{ ...mapActions([ 'increment',// 将`this.increment()`映射为`this.$store.commit('increment')` // `mapMutations`也支持载荷: 'incrementBy' // 将`this.incrementBy(amount)`映射为`this.$store.commit('incrementBy',amount)` ]) } ","date":"2024-01-08","objectID":"/posts/vuep13/:2:4","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Module 由于使用单一状态树，当项目的状态非常多时，store对象就会变得十分臃肿。因此，Vuex允许我们将store分割成模块（Module） 每个模块拥有独立的State、Getter、Mutation和Action，模块之中还可以嵌套模块，每一级都有着相同的结构。 const moduleA = { state:()=\u003e({...}), mutations:{...}, actions:{...}, getters:{...} } const moduleB = { state:()=\u003e({...}), mutations:{...}, actions:{...} } const store = createStore({ modules:{ a:moduleA, b:moduleB } }) store.state.a // -\u003emoduleA的状态 store.state.b // -\u003emoduleB的状态 ","date":"2024-01-08","objectID":"/posts/vuep13/:2:5","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"总结 作为一个状态管理器，首先要有保管状态的容器——State； 为了满足衍生数据和数据链的需求，从而有了Getter； 为了可以“显式地”修改状态，所以需要Mutation； 为了可以“异步地”修改状态（满足AJAX等异步数据交互），所以需要Action； 最后，如果应用有成百上千个状态，放在一起会显得十分庞杂，所以分模块管理（Module）也是必不可少的； Vuex并不是Vue应用开发的必选项，在使用时，应先考虑项目的规模和特点，有选择地进行取舍，对于小型应用来说，完全没有必要引入状态管理，因为这会带来更多的开发成本； ","date":"2024-01-08","objectID":"/posts/vuep13/:3:0","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 vue vuex-demo创建vue文件 终端安装vuex npm install vuex@3 在src文件夹下创建store/index.js文件，导入vue和vuex import Vue from \"vue\"; import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store 在main.js文件里面导入store import Vue from 'vue' import App from './App.vue' import store from './store' Vue.config.productionTip = false new Vue({ render: h =\u003e h(App), store }).$mount('#app') 在HelloWorld.vue里面调用数据 \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e {{this.$store.state.count}} \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'HelloWorld', } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e 修改App.vue为 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cHelloWorld/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components: { HelloWorld } } \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e HelloWorld.vue里面添加+1按钮 \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e {{this.$store.state.count}} \u003cbutton @click=\"add\"\u003e+1\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'HelloWorld', methods:{ add(){ // this.$store.state.count = this.$store.state.count+1 this.$store.commit(\"increment\") } } } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e 使用mapState辅助函数 HelloWorld.vue \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e \u003c!-- {{this.$store.state.count}} --\u003e {{count}} \u003cbutton @click=\"add\"\u003e+1\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { mapState } from 'vuex' export default { name: 'HelloWorld', // computed:{ // count(){ // return this.$store.state.count // } // }, computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]), methods:{ add(){ // this.$store.state.count = this.$store.state.count+1 this.$store.commit(\"increment\") } } } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { // ... computed: mapState({ // 箭头函数可使代码更简练 count: state =\u003e state.count, // 传字符串参数 'count' 等同于 `state =\u003e state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) 使用Getter里面的Todos HelloWorld.vue \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e {{count}} \u003cbutton @click=\"add\"\u003e+1\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"todo in doneTodos\" :key=\"todo.id\"\u003e{{todo.text}}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { mapState,mapGetters } from 'vuex' export default { name: 'HelloWorld', computed: { ...mapState([ 'count','todos' ]), ...mapGetters([ 'doneTodos' ]) }, methods:{ add(){ // this.$store.state.count = this.$store.state.count+1 this.$store.commit(\"increment\") } }, getters: { doneTodos: state =\u003e { return state.todos.filter(todo =\u003e todo.done) } } } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e index.js import Vue from \"vue\"; import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0, todos: [ { id: 1, text: 'eat', done: true }, { id: 2, text: 'sleep', done: false } ] }, mutations: { increment (state) { state.count++ } }, getters: { doneTodos: state =\u003e { return state.todos.filter(todo =\u003e todo.done) } } }) export default store 使用Mutations里面的Payload HelloWorld.vue \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e \u003c!-- {{this.$store.state.count}} --\u003e {{count}} \u003cbutton @click=\"add\"\u003e+1\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"todo in doneTodos\" :key=\"todo.id\"\u003e{{todo.text}}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { mapState,mapGetters } from 'vuex' export default { name: 'HelloWorld', computed: { ...mapState([ 'count','todos' ]), ...mapGetters([ 'doneTodos' ]) }, methods:{ add(){ this.$store.commit(\"increment\",2) } }, getters: { doneTodos: state =\u003e { return state.todos.filter(todo =\u003e todo.done) } } } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e index.js import V","date":"2024-01-08","objectID":"/posts/vuep13/:4:0","tags":["个人学习","前端"],"title":"全栈学习·状态管理VueX","uri":"/posts/vuep13/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"VueRouter的安装与使用 Vue路由vue-router是官方的路由插件，能够轻松的管理 SPA 项目中组件的切换 Vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来 vue-router 目前有 3.x 的版本和 4.x 的版本，vue-router 3.x 只能结合 vue2进行使用，vue-router 4.x 只能结合 vue3 进行使用 安装： npm install vue-router@4 官网： https://v3.router.vuejs.org/zh/guide/ ","date":"2024-01-08","objectID":"/posts/vuep12/:1:0","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"vue-router安装 cmd输入 vue create router-demo 上下键换行选择**Manually select features** 上下键换行，空格取消选中Linter/Formatter，确定后回车 上下键换行，选择2.x版本 上下键换行，选择In package.json 不保存预设，输入N后回车 打开项目，在终端输入指令安装Vue.Router3 npm install vue-router@3 ","date":"2024-01-08","objectID":"/posts/vuep12/:1:1","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建路由组件 在项目中定义Discover.vue、Friends.vue、My.vue三个组件，将来要使用vue-router来控制它们的展示与切换： Discover.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e发现音乐\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e Friends.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e关注\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e My.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e我的音乐\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2024-01-08","objectID":"/posts/vuep12/:1:2","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"声明路由链接和占位标签 可以使用\u003crouter-link\u003e标签来声明路由链接，并使用\u003crouter-view\u003e标签来声明路由占位符。示例代码如下： App.vue \u003cdiv id=\"app\"\u003e \u003ch1\u003eAPP组件\u003c/h1\u003e \u003c!-- 声明路由链接 --\u003e \u003crouter-link to=\"/discover\"\u003e发现音乐\u003c/router-link\u003e \u003crouter-link to=\"/my\"\u003e我的音乐\u003c/router-link\u003e \u003crouter-link to=\"/friends\"\u003e关注\u003c/router-link\u003e \u003c!-- 声明路由占位标签 --\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2024-01-08","objectID":"/posts/vuep12/:1:3","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建路由模块 在项目中创建router文件夹，下面的index.js路由模块，加入以下代码： import VueRouter from \"vue-router\"; import Vue from \"vue\"; import Discover from '../components/Discover.vue' import Friends from '../components/Friends.vue' import My from '../components/My.vue' // 将VueRouter设置为Vue的插件 Vue.use(VueRouter) const router = new VueRouter({ // 指定hash属性与组件的对应关系 routes:[ {path:'/discover',component:Discover}, {path:'/friends',component:Friends}, {path:'/my',component:My}, ] }) export default router 接着在main.js里面导入router import Vue from 'vue' import App from './App.vue' import router from './router' Vue.config.productionTip = false new Vue({ render: h =\u003e h(App), router:router }).$mount('#app') ","date":"2024-01-08","objectID":"/posts/vuep12/:1:4","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"路由重定向 路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面。 通过路由规则的redirect属性，指定一个新的路由地址，可以很方便地设置路由的重定向： const router = new VueRouter({ // 指定hash属性与组件的对应关系 routes:[ // 当用户访问 / 时，跳转到/discover {path:'/',redirect:'/discover'}, {path:'/discover',component:Discover}, {path:'/friends',component:Friends}, {path:'/my',component:My}, ] }) ","date":"2024-01-08","objectID":"/posts/vuep12/:1:5","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"嵌套路由 在Discover.vue组件中，声明toplist和playlist的子路由链接以及子路由占位符。示例代码如下： \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e发现音乐\u003c/h1\u003e \u003c!-- 子路由链接 --\u003e \u003crouter-link to=\"/discover/toplist\"\u003e推荐\u003c/router-link\u003e \u003crouter-link to=\"/discover/playlist\"\u003e歌单\u003c/router-link\u003e \u003chr\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e \u003c/template\u003e 在src/router/index.js路由模块中，导入需要的组件，并使用children属性声明子路由规则： const router = new VueRouter({ // 指定hash属性与组件的对应关系 routes:[ // 当用户访问 / 时，跳转到/discover {path:'/',redirect:'/discover'}, { path:'/discover', component:Discover, // 通过children属性，嵌套声明子路由 children:[ {path:'toplist',component:TopList}, {path:'playlist',component:PlayList}, ] }, {path:'/friends',component:Friends}, {path:'/my',component:My}, ] }) ","date":"2024-01-08","objectID":"/posts/vuep12/:1:6","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"动态路由 思考：有如下3个路由链接： \u003crouter-link to=\"/product/1\"\u003e商品1\u003c/router-link\u003e \u003crouter-link to=\"/product/2\"\u003e商品2\u003c/router-link\u003e \u003crouter-link to=\"/product/3\"\u003e商品3\u003c/router-link\u003e const router = new VueRouter({ // 指定hash属性与组件的对应关系 routes:[ {path:'/product/1',component:Product}, {path:'/product/2',component:Product}, {path:'/product/3',component:Product}, ] }) 上述方式复用性非常差。 动态路由指的是：把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性。在vue-router中使用英文的冒号（:）来定义路由的参数项。示例代码如下： {path:'/product/:id',component:Product} 通过动态路由匹配的方式渲染出来的组件中，可以使用$route.params对象访问到动态匹配的参数值，比如在商品详情组件的内部，根据id值，请求不同的商品数据。 \u003ctemplate\u003e \u003ch1\u003eProduct组件\u003c/h1\u003e \u003c!-- 获取动态的id值 --\u003e \u003cp\u003e{{$route.params.id}}\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e export default { // 组件的名称 name:'Product' } \u003c/script\u003e 为了简化路由参数的获取形式，vue-router允许在路由规则中开启props传参。示例代码如下： {path:'/product/:id',component:Product,props:true} \u003ctemplate\u003e \u003ch1\u003eProduct组件\u003c/h1\u003e \u003c!-- 获取动态的id值 --\u003e \u003cp\u003e{{id}}\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e export default { // 组件的名称 name:'Product', props:[\"id\"] } \u003c/script\u003e ","date":"2024-01-08","objectID":"/posts/vuep12/:1:7","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"声明式导航 声明式 编程式 \u003crouter-link:to=\"...\"\u003e route.push(...) 除了使用\u003crouter-link\u003e时，这个方法会在内部调用，所以说，点击 \u003crouter-link:to=\"...\"\u003e等同于调用router.push(...)。 \u003ctemplate\u003e \u003cbutton @click=\"gotProduct(2)\"\u003e跳转到商品2\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default{ methods:{ gotProduct: function(id){ this.$router.push('/movie/${id}') } } } \u003c/script\u003e ","date":"2024-01-08","objectID":"/posts/vuep12/:1:8","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"导航守卫 导航守卫可以控制路由的访问权限。 全局导航守卫会拦截每个路由规则，从而对每个路由进行访问权限的控制。 你可以使用router.beforeEach注册一个全局前置守卫： // 这是伪代码 router.beforeEach((to,from,next)=\u003e{ if(to.path === '/main' \u0026\u0026 !isAuthenticated){ next('/login') }else{ next() } }) to:即将要加入的目标 from:当前导航正要离开的路由 在守卫方法中如果声明了next形参，则必须调用next()函数，否则不允许用户访问任何一个路由！ 直接放行：next() 强制其停留在当前页面：next(false) 强制其跳转到登录页面：next(’/login') ","date":"2024-01-08","objectID":"/posts/vuep12/:1:9","tags":["个人学习","前端"],"title":"全栈学习·前端路由VueRouter","uri":"/posts/vuep12/"},{"categories":[],"content":"2024-01-08 使用Picx创建了网站图床 ","date":"2023-12-29","objectID":"/website/:0:1","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-26 强行把网站运行时间和版权信息写在了同一行(页脚就两行信息)，否则全页显示会多出一截，强迫症，难受。 ","date":"2023-12-29","objectID":"/website/:0:2","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-25 添加了友链界面，增加了友链表现的css样式，添加了友链内容。 ","date":"2023-12-29","objectID":"/website/:0:3","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-22 添加了最近更新集合，文章按月分类，在分类标题上添加了文章数量统计。 开启了评论功能，选择使用valine引擎。 ","date":"2023-12-29","objectID":"/website/:0:4","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-21 添加了网站离开和返回的标题变化功能。 添加了文章末尾的提示信息。 ","date":"2023-12-29","objectID":"/website/:0:5","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-20 更新了网站头像，添加了网站图标，更改了鼠标放置在图片上显示的文字。 更新了所有文章开头的默认数据。 ","date":"2023-12-29","objectID":"/website/:0:6","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-19 添加了菜单栏每项前面的图标。 添加了默认语言为CN的代码，终于解决了子页标题怎么改都是英文的毛病了。 ","date":"2023-12-29","objectID":"/website/:0:7","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-18 添加了不蒜子统计，网站浏览量和文章阅读量可以显示了，文章发布时间与更新时间可以显示了，网站运行时间可以查看了。 添加了页脚分界线。 ","date":"2023-12-29","objectID":"/website/:0:8","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-12 解决了分类和标签项点击后无法跳转文章集合页面的问题。 ","date":"2023-12-29","objectID":"/website/:0:9","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-11 添加了网页左上角跳转GitHub的小图标。 添加了主页头像下的四个其他平台联系方式。 ","date":"2023-12-29","objectID":"/website/:0:10","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-08 暂时性的搭完了个人网站，使得网站具有可读性。 ","date":"2023-12-29","objectID":"/website/:0:11","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-06~07 发表了一些文章，并对文章开头默认添加的代码进行了修改 ","date":"2023-12-29","objectID":"/website/:0:12","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-05 测试了一些功能，报了一些错，重新创建reposity并进行链接 ","date":"2023-12-29","objectID":"/website/:0:13","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-04 修改了网站的头像、主页内容 ","date":"2023-12-29","objectID":"/website/:0:14","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-12-01 初步搭建了网站的框架，包括页眉、页脚、菜单栏等等，修改了网站配置文件里面的一些默认设置。 ","date":"2023-12-29","objectID":"/website/:0:15","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-11-30 确定网站使用LoveIt主题。 ","date":"2023-12-29","objectID":"/website/:0:16","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":[],"content":"2023-11-29 心血来潮准备建一个自己的个人博客，存放一些学习记录。 初步定下了使用Hugo搭建个人网站。 ","date":"2023-12-29","objectID":"/website/:0:17","tags":[],"title":"建站日志⚙","uri":"/website/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios的使用 ","date":"2023-12-29","objectID":"/posts/vuep11/:1:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios简介 使用背景：在实际项目开发中，前端页面所需要的数据往往需要从服务器端获取，这必然涉及与服务器的通信。 Axios主要是前端的一个网络请求框架，大部分基于Ajax Axios基于promise网络请求库，作用与node.js和浏览器中。 Axios在浏览器端使用XMLHttpRequests发送网络请求，并能自动完成JSON数据的转换。 地址 https://www.axios-http.cn/ ","date":"2023-12-29","objectID":"/posts/vuep11/:1:1","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios的安装和导入 安装：输入 npm install axios 导入：在文件开头输入 import axios from 'axios' ","date":"2023-12-29","objectID":"/posts/vuep11/:1:2","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Axios发送请求的方式 这可以与Springboot的GetMapping对应 发送GET请求（通过url传参） 示例代码如下： //向给定ID的用户发起请求 axios.get('/user?ID=12345') .then(function(response){ //若处理成功 console.log(response); }) .catch(function(error){ //若处理失败 console.log(error); }) .then(function(){ //总是执行 }); //上述请求也可以按以下方式完成 axios.get('/user',{ params:{ ID:12345 } }) .then(function(response){ //若处理成功 console.log(response); }) .catch(function(error){ //若处理失败 console.log(error); }) .then(function(){ //总是执行 }); 关于上述代码： 如果请求成功，系统会调用.then()；如果请求失败或出现错误，则会调用.catch()。 .then()与.catch()就是promise相关的语法。 .then()内需要传入一个回调函数（function(response)），.catch()也需要传入一个回调函数（function(error)），这些都是自定义的函数。 get请求如果想给后端传递数据，可以通过? String的方式传参（Springboot的时候说过）；如果参数较多，可以通过params（在后面再传一个参，参数是对象，对象内可以放多种配置）传参。 最后可以加一个.then()方法，不论成功或失败都执行该方法。 发送POST请求（通过请求体传参） 示例代码如下： axios.post('/user',{ firstName:'Fred', lastName:'Flintstone' }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) 关于上述代码： 用{}括起来，就会放在请求体内传参，而且需要注意的是：Axois会自动把请求体里面的数据转为JSON格式传送给后端。后端处理POST请求时，需要注意它是JSON的格式，作特殊的处理。 异步回调问题 //async/await的用法 async function getUser(){ try{ const response = await axios.get('/user?ID=12345'); console.log(response); }catch(error){ console.log(error); } } JavaScript最新的标准里面，有async和await的语法结构。 前面GET和POST都涉及了异步回调获取数据的形式，如果需要同步获取数据，则可以通过前面加一个async（方法内必须有配对的await）实现。 当方法前面加了async之后，发送异步请求的前面就可以加上await，无需再添加回调函数（即.then()），直接拿到响应，以同步的形式取代异步的编程。 不过常用的还是加回调函数的方式。 其他请求方式 参考： https://axios-http.com/zh/docs/req_config 更详细的配置项可以去官网文档查询。 ","date":"2023-12-29","objectID":"/posts/vuep11/:1:3","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"与Vue整合 axios不能直接写在\u003cscript\u003e标签内，因为网络请求下来的数据最终还是要交给data的。 目前虽然data中的电影信息是我们自己写的，但这些数据本应该是从数据库中查询出来交给前端的，最终再放在data里面去。 因为这个请求最终需要交给data，所以axios需要写在vue范围内（即export default{}内）。 Vue内部提供的一些生命周期的函数，即对于我们现在的组件App.vue来讲，从创建到加载、渲染、销毁，每一个阶段会有对应的函数。[例如：该组件在程序运行时会被创建，接下来加载到界面（绑定/挂载到界面），当页面切换了（即切换到其他组件上了），该组件就会被销毁] 其中，created要和data平级（不能放在methods:里面，这里面放的是自定义的函数），当组件被创建的时候，created:function()会被自动调用。 还有一个类似的方法叫mounted，这个方法作用时间会稍微迟一点，被挂载（渲染到界面上）的时候调用。（其他的方法/生命周期可以在vue.js官网上查看。） 示例代码如下： ...... \u003cscript\u003e import Movie from './compents/Movie.vue' import Hello from './compents/Hello.vue' import axios from 'axios' export default{ name:'App', data:function(){ return{ movies:[ {id:1,title:\"金刚狼1\",rating:8.7}, {id:1,title:\"金刚狼2\",rating:8.8}, {id:1,title:\"金刚狼3\",rating:8.6}, ] } }, created:function(){ console.log(\"App组件被创建了\") }, mounted:function(){ console.log(\"App被挂载完毕\") }, components:{ Movie, Hello } } \u003c/script\u003e ...... ","date":"2023-12-29","objectID":"/posts/vuep11/:2:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域 ","date":"2023-12-29","objectID":"/posts/vuep11/:3:0","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"和后端进行关联 首先，需要修改后端启动的端口：server.port=8088，再启动。 在created:function(){}里面写的axois.get(\"\")，它这个链接的发送需要有一个后端的接口。（比如说，想要控制器查询所有的用户，url访问其中的一个控制器，localhost:8088/user/findAll，就能看见所有的数据。）（TIPS：一般来说如果要查看问题，可以在网页处右键→检查→network） 所以axois.get(\"\")里面写↓ axios.get(\"http://localhost:8088/user/findAll\").then(function(response){console.log(response)}) 该处get请求一经发送，正好对应后端的@GetMapping，于是就拿到数据。（注意，虽然created先执行，但是里面的console.log()是异步回调函数，所以输出的文本先后并不代表方法调用的先后） 但是！还是会失败并报错的！ 这是跨域问题引起的↓ ","date":"2023-12-29","objectID":"/posts/vuep11/:3:1","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域问题 为什么会出现跨域问题 为了保证浏览器的安全,不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源，称为同源策略,同源策略是浏览器安全的基石 同源策略(Sameoriginpolicy) 是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源(即指在同一个域)就是两个页面具有相同的协议(protocol) ，主机(host) 和端口号(port) 当一个请求url的协议、 域名、端口三者之间任意-个与当前页面url不同即为跨域，此时无法读取非同源网页的Cookie,无法向非同源地址发送AJAX请求 跨域问题解决 CORS (Cross-Origin Resource Sharing)是由W3C制定的一种跨域资源共享技术标准，其目的就是为了解决前端的跨域请求。 CORS可以在不破坏即有规则的情况下，通过后端服务器实现CORS接口,从而实现跨域通信。 CORS将请求分为两类：简单请求和非简单请求，分别对跨域通信提供了支持。 简单请求的服务器处理 对于简单请求，CORS的策略是请求时在请求头中增加一个Origin字段 Host:localhost:8080 Origin:http://localhost:8081 Referer:http://localhost:8081/index.html 服务器收到请求后， 根据该字段判断是否允许该请求访问，如果允许，则在HTTP头信息中添加Access-Control- Allw-Origin字段。 Access-Control-Allow-Origin:http://localhost:8081 Content-Length:20 Content-Type:text/plain;charset=UTF-8 Date:Thu,12 Jul 2018 12:51:14 GMT 非简单请求 对于非简单请求的跨源请求，浏览器会在真实请求发出前增加一次OPTION请求，称为预检请求(preflight request) 预检请求将真实请求的信息，包括请求方法、自定义头字段、源信息添加到HTTP头信息字段中，询问服务器是否允许这样的操作。 例如一个GET请求: OPTIONS/test HTTP/1.1 origin:http://ww.test.com Access-Control-Request-Method:GET Access-Control-Request-Headers:X-Custom-Header Host:www.test.com Access-Control-Request-Method表示请求使用的HTTP方法，Access-Control-Request-Headers包含请求的自定义头字段 服务器收到请求时，需要分别对Origin、 Access-Control-Request-Method、Access-Control-Request-Headers进行验证，验证通过后，会在返回HTTP头信息中添加: Access-Control-Allow-Origin: http://www.test.com Access-Control-Allow-Methods: GET,POST,PUT,DELETE Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials:true Access-Control-Max-Age: 1728000 Access-Control-Allow-Methods、Access -Control-Allow-Headers:真实请求允许的方法、允许使用的字段 Accss-Control-Allow-Credentials: 是否允许用户发送、处理cookie Access-Control-Max-Age:预检请求的有效期，单位为秒，有效期内不会重新发送预检请求。 Spring Boot中配置CORS 在传统的Java EE开发中，可以通过过滤器统一配置, 而Spring Boot中对此则提供了更加简洁的解决方案： @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry){ registry.addMapping(\"/**\")//允许跨域访问的路径 .allowedOrigins(\"*\")//允许跨域访问的源 .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\")//允许请求方法 .maxAge(168000)//预检间隔时间 .allowedHeaders(\"*\") //允许头部设置 .allowCredentials(true);//是否发送cookie } } ","date":"2023-12-29","objectID":"/posts/vuep11/:3:2","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"跨域问题解决方法 在控制器之前加注解@CrossOrigin，使得控制器里面所有的方法都允许被跨域。要么就加一个配置类，使得所有的控制器都能被跨域。（加完之后重启服务器） 拿到以后渲染到界面上：赋值给data，把response.data取出来，显示到表格里面。直接this.tableData = response.data就可以了。 解决回调函数this作用域的限制：改写.成then(response)=\u003e{} 每个组件都要导入axios，以及写相同的域名localhost:8088，可以抽出来进行整合。（在main.js里面做一个统一的导入） 与Vue整合 在实际项目开发中，几乎每个组件中都会用到axios发起数据请求。此时会遇到如下两个问题: 每个组件中都需要导入axios 每次发请求都需要填写完整的请求路径 可以通过全局配置的方式解决上述问题(写入main.js): //配置请求根路径 axios.defaults.baseURL = 'http://localhost:8088' //将axios 作为全局的自定义属性，每个组件可以在内部直接访问(Vue3) app.config.globalProperties.$http = axios //将axios 作为全局的自定义属性，每个组件可以在内部直接访间(Vue2)← Vue.prototype.$http = axios ","date":"2023-12-29","objectID":"/posts/vuep11/:3:3","tags":["个人学习","前端","后端"],"title":"全栈学习·Axios网络请求","uri":"/posts/vuep11/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"组件间的传值 组件可以由内部的Data提供数据，也可以由父组件通过prop的方式传值 兄弟组件之间可以通过Vuex等统一数据源提供数据共享 项目创建（Vue2） 终端输入 vue create component-demo 把Linter取消选中 选择Vue2 创建 Vue2与Vue3的差异（主要在main.js中）： Vue3通过create app创建Vue对象，Vue2通过new Vue创建Vue对象 Vue3使用的是.mount，Vue2使用的是.$mount ","date":"2023-12-12","objectID":"/posts/vuep10/:1:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Element-ui Element是国内饿了么公司提供的一套开源前端框架，简洁优雅，提供了Vue、React、Angular等多个版本。 文档地址：https://element.eleme.cn/#/zh-CN/ 安装： npm i element-ui 引入Element // 在main.js文件头中加入 import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; 注册Element // 在main.js文件中写入 Vue.use(ElementUI); （如果node_modules没了，可以直接npm install重新下载依赖） ","date":"2023-12-12","objectID":"/posts/vuep10/:2:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"第三方图标库FontAwesome 由于Element UI提供的字体图符较少，一般会采用其他图表库，如著名的FontAwesome Font Awesome提供了675个可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括大小、颜色、阴影或者其他任何支持的效果。 文档地址: http://fontawesome.dashgame.com/ 安装: npm install font-awesome 使用（在main.js中写入）: import 'font-awesome/css/font-awesome.min.css' ","date":"2023-12-12","objectID":"/posts/vuep10/:3:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操代码 App.vue文件 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cMovie v-for=\"movie in movies\" :key=\"movie.id\" :title=\"movie.title\" :rating=\"movie.rating\"\u003e\u003c/movie\u003e \u003chello\u003e\u003c/hello\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Movie from './components/Movie.vue' import Hello from './components/hello.vue' import axios from 'axios' export default { name: 'App', data:function(){ return{ movies:[ {id:1,title:\"Tranformers1\",rating:8.9}, {id:2,title:\"Tranformers2\",rating:8.8}, {id:3,title:\"Tranformers3\",rating:8.7}, ] } }, created:function(){ console.log(\"APP组件被创建了\") }, components: { Movie, Hello } } \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e Movie.vue文件 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e{{title}}\u003c/h1\u003e \u003cspan\u003e{{rating}}\u003c/span\u003e \u003cbutton @click=\"fun\"\u003e点击收藏\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default {//导出，vue.app做导入，正好对应 name:\"Movie\", props:[\"title\",\"rating\"], data:function(){ return{ } }, created: function(){ console.log(\"Movie组件被创建了\") }, mounted:function(){ console.log(\"APP组件被创建了\") }, methods:{ fun(){ alert(\"收藏成功\") } } } \u003c/script\u003e hello.vue文件 \u003ctemplate\u003e \u003cdiv\u003e \u003cel-table :data=\"tableData\" style=\"width: 100%\" :row-class-name=\"tableRowClassName\"\u003e \u003cel-table-column prop=\"date\" label=\"日期\" width=\"180\"\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"name\" label=\"姓名\" width=\"180\"\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"address\" label=\"地址\"\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e \u003ci class=\"fa fa-camera-retro\"\u003e\u003c/i\u003e \u003cel-date-picker v-model=\"value1\" type=\"date\" placeholder=\"选择日期\"\u003e \u003c/el-date-picker\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e .el-table .warning-row { background: oldlace; } .el-table .success-row { background: #f0f9eb; } \u003c/style\u003e \u003cscript\u003e export default { methods: { tableRowClassName({row, rowIndex}) { if (rowIndex === 1) { return 'warning-row'; } else if (rowIndex === 3) { return 'success-row'; } return ''; } }, data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } } } \u003c/script\u003e ","date":"2023-12-12","objectID":"/posts/vuep10/:4:0","tags":["个人学习","前端"],"title":"全栈学习·第三方组件（element-ui）","uri":"/posts/vuep10/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"NPM使用 NPM简介 NPM (Node Package Manager)是一个NodeJS包管理和分发工具。 NPM以其优秀的依赖管理机制和庞大的用户群体，目前已经发展成为整个JS领域的依赖管理工具 NPM最常见的用法就是用于安装和更新依赖。要使用NPM，首先要安装Node工具。 ","date":"2023-12-11","objectID":"/posts/vuep9/:1:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"NPM\u0026Vue下载安装 进入https://nodejs.org/en网站下载Node.js 打开msi安装包一直点击next完成安装 win+R打开终端，进入项目路径，输入 npm install -g @vue/cli （网络问题可以先输入下面代码更换代理再安装） npm config set registry https://registry.npm.taobao.org ","date":"2023-12-11","objectID":"/posts/vuep9/:2:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue CLI使用 ","date":"2023-12-11","objectID":"/posts/vuep9/:3:0","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建Vue项目 输入 vue create hello 上下键切换选项，选择Manually select features选项，并回车 上下切换选项，空格选中/取消选中，空格取消选中Linter/Formatter选项，并回车 选择3.x版本并回车 选择不存储预选，输入N ","date":"2023-12-11","objectID":"/posts/vuep9/:3:1","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue文件基本结构 package.json：配置文件，记录项目基本信息 src：写代码的目录 main.js:主要用到模块化开发的思想（区别于组件化），目前前端项目基本通过import的方式导入各类模块。（早期的前端代码主要通过script标签去引入各类文件） 第一行：通过vue导入其createApp方法 第二行：导入了app.vue的app 调用createApp方法，把app传过去，同时将其mount到了#app标签上（标签在public的index.html里） main.js全部代码如下： import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') Vue.app： \u003ctemplate\u003e：放组件的标签、文本、结构，放置了： img标签 helloworld标签（自定义组件，在components里面，可以删掉自己写） \u003cscript\u003e:放组件的一些行为 \u003cstyle\u003e：放组件的一些css的样式 Vue.app全部代码如下：： \u003ctemplate\u003e \u003cimg alt=\"Vue logo\" src=\"./assets/logo.png\"\u003e \u003cHelloWorld msg=\"Welcome to Your Vue.js App\"/\u003e \u003c/template\u003e \u003cscript\u003e import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components: { HelloWorld } } \u003c/script\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u003c/style\u003e ","date":"2023-12-11","objectID":"/posts/vuep9/:3:2","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"运行Vue项目 打开终端，输入： npm run serve ","date":"2023-12-11","objectID":"/posts/vuep9/:3:3","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"自定义组件 使用import导入,例如： import HelloWorld from './components/HelloWorld.vue' 导入结束后进行注册: export default { name: 'App', components: { HelloWorld } } (1、2步代码都放在script内) 创建.vue文件自定义组件：添加\u003ctemplate\u003e、\u003cscript\u003e、\u003cstyle\u003e标签,在标签里简单加入内容即可 (可以安装Vetur插件着色代码） ","date":"2023-12-11","objectID":"/posts/vuep9/:3:4","tags":["个人学习","前端"],"title":"全栈学习·Vue组件化\u0026模块化开发","uri":"/posts/vuep9/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"\r信息\r需要前端基础html、css、js\r","date":"2023-12-06","objectID":"/posts/vuep8/:0:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Vue框架介绍 vue是一套用于构建用户界面的渐进式框架。 vue.js提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。 其目标是通过尽可能简单的API实现响应式的数据绑定和可组合的视图组件。 ","date":"2023-12-06","objectID":"/posts/vuep8/:1:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"MVVM模式 MVVM基于MVC（Model-View-Controller)但是在Controller上作了修改 MVVM是Model-View-ViewModel的缩写，它是一种基于前端开发的架构模式，其核心是提供对View和ViewModel的双向数据绑定。 Vue提供了MVVM风格的双向数据绑定。核心是MVM中的VM，也就是 ViewModel,ViewModel负责连接View和Model，保证视图和数据的一致性。 ","date":"2023-12-06","objectID":"/posts/vuep8/:2:0","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 （使用VScode） 创建html文件，使用！+Enter，生成代码，去代码copy链接↓ \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 调用CreateApp的方法，且告知渲染至哪（扩展→Open in browser插件，run的时候就能从浏览器快速打开） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e{{ message }}\u003c/div\u003e \u003cscript\u003e const { createApp } = Vue createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 演示代码文件: “：”后为变量或表达式，属性的绑定需要加“：”，不加会变成字段。 01. 基本用法 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e{{ message }}\u003c/div\u003e \u003cscript\u003e const { createApp } = Vue createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 02. 内容渲染指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cp\u003e姓名:{{username}}\u003c/p\u003e \u003cp\u003e性别：{{gender}}\u003c/p\u003e \u003c!-- 花括号是vue里面的data模板，会做一些渲染。 对http不会进行渲染，但是使用v-html可以进行渲染 --\u003e \u003cp\u003e{{desc}}\u003c/p\u003e \u003cp v-html=\"desc\"\u003e\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data:function(){ return{ username:'zhangsan', gender:'男', desc:'\u003ca href=\"http://www.baidu.com\"\u003e百度\u003c/a\u003e' } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 03. 属性绑定指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ca :href=\"link\"\u003e百度\u003c/a\u003e \u003c!-- 冒号就是进行渲染，这里把link放在这，vue就会把值渲染到超链接上 --\u003e \u003cinput type=\"text\" :placeholder=\"inputValue\"\u003e \u003cimg :src=\"imgSrc\" :style=\"{width:w}\" alt=\"\"\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data: function(){ return{ link:\"http://www.baidu.com\", //文本框的占位符内容 inputValue:'请输入内容', //图片的src地址 imgSrc:'./images/demo.png', w:'500px' } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 04. 使用JavaScript表达式 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cp\u003e{{number + 1}}\u003c/p\u003e \u003cp\u003e{{ok ? 'True' : 'False'}}\u003c/p\u003e \u003cp\u003e{{message.split('').reverse().join('')}}\u003c/p\u003e \u003cp :id=\"'list-' + id\"\u003exxx\u003c/p\u003e \u003cp\u003e{{user.name}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data :function(){ return{ number:9, ok:false, message:'AAA+ABC', id:3, user:{ name:'zs', } } } } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 05. 事件绑定指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch3\u003ecount的值为：{{count}}\u003c/h3\u003e \u003cbutton v-on:click=\"addCount\"\u003e+1\u003c/button\u003e \u003cbutton @click=\"count+=1\"\u003e+1\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e const vm = { data:function(){ return{ count:0, } }, methods:{ //点击按钮，让count+1 addCount(){ this.count+=1 }, }, } const app = Vue.createApp(vm) app.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 06. 条件渲染指令 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@3/dist/vue.global.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cbu","date":"2023-12-06","objectID":"/posts/vuep8/:2:1","tags":["个人学习","前端"],"title":"全栈学习·Vue框架介绍及应用","uri":"/posts/vuep8/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mybatis多表查询 实现复杂关系映射，可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置。 注解 说明 @Reults 代替标签,该注解中可以加入单个或多个@Result注解 @Result 代替标签和标签，@Result中可以使用以下属性: - column: 数据表的字段名称 - property:类中对应的属性名 - one:与@one注解配合，进行一对一的映射 - many: 与@Many注解配合，进行一对多的映射 @One 代替标签，用于指定查询中返回的单一对象 通过select属性指定用于多表查询的方法 使用格式:@Result(column=\"\",property=\"\",one=@one(select=\"\")) @Many 代替标签,用于指定查询中返回的集合对象 使用格式:@Result(column=\"\",property=\"\",many=@Many(select=\"\")) 实际使用 要查同一用户下的所有订单：加入一个字段orders，字段orders并不存在，其属性为List集合，存放的是订单对象Orders。 TableName(\"t_user\") public class User { @TableId(type = IdType .AUT0) private int id; priwate string username ; private string password; private string birthday ; //描述用户的所有订单 @TableField(exist = false) private List\u003c0rder\u003eorders; //alt + insert ………… 这个字段需要自行映射 ………… //查询用户及其所有的订单 @Select(\"\"select * from t_user\"\") @Results( { @Result(column = \"id\" , property = \"id\"), @Result(column = \"username\" , property = \"username\"), @Result(column = \"password\" , property = \"password\"\"), @Result(column = \"birthday\" , property = \"birthday\"\") , @Result(column = \"id \" , property = \"orders\",javaType = List.class, many=@Many(select = \"com.example.mpdemo.mapper.OrderMapper.selectBy…… ) } } List\u003cUser\u003e selectAllUserAnd0rders(); } 前面意思是↑从数据库里面调取的id这一列需要赋值给user类中的id属性。 关键在于映射orders：最后一行，标记需要使用id字段，需要映射orders，类型为集合list。还需要写一个方法： @Select(\"select * from t_order where uid = #{uid}\") List\u003cOrder\u003e selettByUid(int uid); many注解，意思是一个用户会有多个订单，后接需要调用哪个mapper的哪个方法（对着mapper右键copy path选最后一个就行）,查询出来的订单最后传给了orders属性，就完成了映射。 如果我们需要查订单的用户：需要用one注解 one=@0ne(select = \"com.example.mpdemo.mapper .UserHapper.selectById\") 条件查询： @GetMapping(\"/user/find\") public List\u003cUser\u003e findBycond(){ QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper(); queryWirapper.eq( \"username\" , \"zhangsan\"); return userMapper.selectList(queryWrapper); } 分页查询： @GetMapping(\"/user/findByPage\") public IPage findByPage(){ //设置起始值及每页条数 Page\u003cUser\u003e page = new Page\u003c\u003e(0, 2) ; IPage iPage = userMapper.selectPage(page, null); return iPage; } ","date":"2023-12-05","objectID":"/posts/springbootp7/:1:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·MybatisPlus多表查询及分页查询","uri":"/posts/springbootp7/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"ORM ORM (Object Relational Mapping,对象关系映射）是为了解决面向对象与关系数据库存在的互不匹配现象的一种技术。 ORM通过使用描述对象和数据库之间映射的元数据将程序中的对象自动持久化到关系数据库中。 ORM框架的本质是简化编程中操作数据库的编码。 ","date":"2023-12-04","objectID":"/posts/springbootp6/:1:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Mybatis-Plus ","date":"2023-12-04","objectID":"/posts/springbootp6/:2:0","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"介绍 MyBatis是一款优秀的数据持久层ORM框架。被广泛地应用于应用系统。 MyBatis能够非常灵活地实现动态SQL。可以使用XML或注解来配置和映射原生信息。能够轻松地将Java的POJO(Plain Ordinary Java Object，普通的Java对象)与数据库中的表和字段进行映射关联。 MyBatis-Plus是一个MyBatis的增强工具。在MyBatis的基础上做了增强。简化了开发。 ","date":"2023-12-04","objectID":"/posts/springbootp6/:2:1","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置 添加依赖到pom.xml：（MybatisPlus其实依赖了Mybatis）（需要准备好Mysql数据库） \u003c!--MyBatisP1us依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.4.2\u003c/version\u003e \u003c/dependency\u003e \u003c! -- mysq1驱动依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysq1-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--数据连接池druid--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.a1ibaba\u003c/groupId\u003e \u003cartifactid\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.20\u003c/version\u003e \u003c/dependency\u003e 加入配置（在.properties)：（使用什么连接池\\数据库、数据库在哪、账号\\密码、日志输出格式）（数据库的组件都在mapper包里，需要给出mapper包路径） ","date":"2023-12-04","objectID":"/posts/springbootp6/:2:2","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 加入控制器 定义mapper相关的组件（要创建的是接口，不是类，名称都以要操作的表+mapper命名）（sql语句都用@注解来实现） 新建user类，存储表中有的字段。（按住alt+insert加入get/set方法）（再加一个toString方法） 加入注解使得方法生效@select(“select * from user”)(记得加入@mapper) 通过@autowired注入参数usermapper内容，再使用find()方法返回用户列表。 改成JSON 插入user对象 int insert()代表插入几条记录，插入失败返回值为0 mysql插入会自增 mybatis会自动帮助你增删改，不需要再自写方法了，只需要告诉其user类 mybatis-plus：当表明与类名不一样时@TableName(“表名“），（以告知mybatis）如果需要id作为组件自增@TableId(type=IdType.AUTO)。 如果不加的话，数据库里面的id可能是自增的值，但是代码print不出来id的值 ","date":"2023-12-04","objectID":"/posts/springbootp6/:2:3","tags":["个人学习","后端","数据库"],"title":"全栈学习·Mybatis-Plus增/删/改","uri":"/posts/springbootp6/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful服务 ","date":"2023-12-03","objectID":"/posts/springbootp5/:1:0","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful介绍 RESTful是一种软件服务架构设计风格 ","date":"2023-12-03","objectID":"/posts/springbootp5/:1:1","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful特点 例如，将请求清晰分类，GET用于获取，POST用于新建，等等等等 每一个URI代表一种资源。 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作:GET用于获取资源,POST用于新建资源(也可以用于更新资源)，PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的。从客户端到服务端的每个请求都包含必需的信息。 ","date":"2023-12-03","objectID":"/posts/springbootp5/:1:2","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"RESTful API（符合此架构接口的必备特质） 符合RESTful规范的Web API需要具备如下两个关键特性: 安全性:安全的方法被期望不会产生任何副作用。当我们使用GET操作获取资源时。不会引起资源本身的改变，也不会引起服务器状态的改变。 幂等性:幂等的方法保证了重复进行一个请求和一次清求的效果相同（并不是指响应总是相同的,而是指服务器上资源的状态从第一次请求后就不再改变了），在数学上幂等性是指N次变换和一次变换相同。 在做BS架构程序时，想要符合RESTful风格，对应几种请求方法即可 实际编程时如何实现RESTful风格： Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API,提供了与REST操作方式(GET.POST、PUT、DELETE)对应的注解： GetMapping:处理GET请求，获取资源。 PostMapping:处理POST请求，新增资源。 putMapping:处理PUT请求，更新资源。 DeleteMapping:处理DELETE请求，删除资源。 PatchMapping:处理PATCH请求，用于部分更新资源。 URL中不要包含动词（传统的比如删除用户操作为http://xxx/del?id=10，但是RESTful需要delete http://xxx/user/10） 示例：（RESTful增删改查）（加**{}意味其为动态**，需要加入PathVariable注解） ","date":"2023-12-03","objectID":"/posts/springbootp5/:1:3","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 全部代码如下 @RestController public class UserController { @GetMapping(\"/user/{id}\") public String getUserById(@PathVariable int id){ System.out.println(id); return \"根据ID获取用户信息\"; } @PostMapping(\"/user\") public String save(User user){return \"添加用户\";} @PutMapping(\"/user\") public String update(User user){return \"更新用户\";} @DeleteMapping(\"/user/{id}\") public String deleteById(@PathVariable int id){ System.out.println(id); return \"根据ID删除用户\"; } } ","date":"2023-12-03","objectID":"/posts/springbootp5/:1:4","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Swagger Java内提供的测试工具 通过Swagger动态生成web接口文档（方便前端使用），也可以进行端口测试 ","date":"2023-12-03","objectID":"/posts/springbootp5/:2:0","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"配置 在pom.xml加入依赖↓ \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e 警告\rSpring Boot 2.6.X后与Swagger有版本冲突问题，需要在application.properties中加入以下配置: spring.mvc.pathmatch.matching-strategy=ant_path_matcher\r然后做一个基本的配置↓（在config下创建一个SwaggerConfig配置类） @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis( RequestHandlerSelectors.basePackage(\"com\")) .paths(PathSelectors.any()).build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"演示项目API\")//标题 .description(\"学习Swagger2的演示项目\")//描述 //附加信息 .build(); } } ","date":"2023-12-03","objectID":"/posts/springbootp5/:2:1","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"使用Swagger2进行接口测试 启动项目访问http://127.0.0.1:8080/swagger-ui.html，即可打开自动生成的可视化测试页面 ","date":"2023-12-03","objectID":"/posts/springbootp5/:2:2","tags":["个人学习","后端"],"title":"全栈学习·RESTful服务+Swagger","uri":"/posts/springbootp5/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Web开发进阶 ","date":"2023-12-02","objectID":"/posts/springbootp4/:1:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"静态资源访问 前后端分离static是不会存放内容的 ","date":"2023-12-02","objectID":"/posts/springbootp4/:1:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 当没有配置静态资源时，直接 “/” 后接 静态资源 名称即可访问（例：localhost:8080/test.jpg） 如果不想放在根路径下直接访问，而希望在资源前面加一个统一路径images方便管理，可以通过static path设置虚拟路径（也叫过滤规则）:在application.properties中加入代码 spring.mvc.static-path-pattern=/images/** 如果在resource下额外创建了一个文件，将静态资源放在自创文件css中，则需要通过static locations进行修改（classpath是整个项目的类路径，在target下的classes，是一个固定的目录） spring.web.resources.static-locations=classpath:/css ","date":"2023-12-02","objectID":"/posts/springbootp4/:1:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"文件上传 ","date":"2023-12-02","objectID":"/posts/springbootp4/:2:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"文件上传原理 传输文件必须要把表单中的enctype（编码类型）改成form-data的类型。 （修改后，例如表单中的字符串字段，还是使用文本形式进行传输；但如果上传的字段是文件，则会与上一个分开，用另外的形式上传） 配置 在application.properties中加入 spring.servlet.multipart.max-file-size=10MB spring.servlet.multipart.max-request-size=10MB 在控制器方法中加入一个特殊的参数MultipartFile（Spring用来接收文件的类型）,通过此对象获取文件信息。 例如：public String upload(String nickname, MultipartFile photo, HttpServletRequest request) ","date":"2023-12-02","objectID":"/posts/springbootp4/:2:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实操 如何动态获取web服务器所在位置（怎么去获取服务器对应路径）： 在方法里加入HttpServletRequest request参数（J2EE提供的原始类，代表网络请求，即前端发送的请求，一个request对象）: public String upload(String nickname, MultipartFile photo, HttpServletRequest request) 通过此对象可以获取该对象的上下文对象（request.getServletContext，也就是该请求的上下文）， 其实也就是web服务器，通过web服务器得到对应的路径（getRealPath)， 其实就得到了web服务器运行的目录，将其存储在自创的虚拟的/upload/目录中: String path = request.getServletContext().getRealPath(\"/upload/\"); 如果status：500，意味着后端出了问题（up是文件太大了） 通过自定义函数savefile判断目录是否存在，如果不存在，则使用path与文件名创建目录，最后使用transferTo方法把文件传输到创建好的目录中。 想让用户通过刚刚创建好的目录访问文件需要在applicaition.properties中加入代码： spring.web.resources/static-locations=/upload/ 全部代码如下 在Controller包下创建FileUploadController类 @RestController public class FileUploadController { @PostMapping(\"/upload\") public String upload(String nickname, MultipartFile photo, HttpServletRequest request)throws IOException{ System.out.println(nickname); System.out.println(photo.getOriginalFilename()); System.out.println(photo.getContentType()); String path = request.getServletContext().getRealPath(\"/upload/\"); System.out.println(path); saveFile(photo,path); return \"success upload\"; } public void saveFile(MultipartFile photo,String path)throws IOException{ File dir=new File(path); if (!dir.exists()){ dir.mkdir(); } File file=new File(path+photo.getOriginalFilename()); photo.transferTo(file); } } ","date":"2023-12-02","objectID":"/posts/springbootp4/:2:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"拦截器 ","date":"2023-12-02","objectID":"/posts/springbootp4/:3:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"有关拦截器 拦截器主要对于不同控制器可能遇见的统一操作（例如获取用户名），做一个处理 用户提交的请求都先到达（自定义的）拦截器，调用prehandle，最终到控制器的目标方法中，到页面渲染结束，再调用afterCompletion prehandle调用的最频繁（例如用户想要提交一个请求，但是没有登录，拦截器可以拦截下请求不让它直接到控制器调用方法，而是先登录） 如果要定义拦截器一般会在后面加Interceptor（然后继承一个系统的拦截器类HandlerInterceptor): public class LoginInterceptor implements HandlerInterceptor 拦截器还需要注册，否则无法使用（需要在Java类里面完成，继承WebMvcConfiguer，一个专门做配置器的类，对于刚才创建的拦截器进行一个Login，然后定义你需要拦截的路径）: public class WebConfig implements WebMvcConfigurer ······ registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/user/**\"); ······ ","date":"2023-12-02","objectID":"/posts/springbootp4/:3:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实际操作 继承HandlerInterceptor（Ctrl+单击进入具体代码） 重写prehandle方法，写完之后还需要配置才生效（此配置一般放在config下）：创建一个类，加入注解Configuration使其生效（效果为Springboot会自动读取此类） 重写副类WebMvcConfigurer，里面提供了添加拦截器的方法 重写addInterceptors方法，调用其传递的registry对象，添加一个拦截器，将刚才Login的拦截器进行new，最后加入拦截路径（不加的话就是拦截所有，可以不加） 全部代码如下 创建Interceptor包，在下面创建LoginInterceptor类： public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler)throws Exception{ System.out.println(\"LoginInterceptor\"); return true; } } 在config下创建WebConfig类： @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry){ // registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/user/**\"); registry.addInterceptor(new LoginInterceptor()); } } ","date":"2023-12-02","objectID":"/posts/springbootp4/:3:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot文件上传\u0026拦截器","uri":"/posts/springbootp4/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Web入门 Spring Web提供了启动器starter，主要包含了三个组件：mvc、json、tomcat。 webmvc组件主要提供web开发的注解（类似于控制器的注解）是web开发的基础框架 json组件主要提供了JSON数据的解析，使能够接收前端发送数据并返回 Tomcat为自带的容器依赖 ","date":"2023-12-01","objectID":"/posts/springbootp3/:1:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"控制器 ","date":"2023-12-01","objectID":"/posts/springbootp3/:2:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"控制器介绍 mvc为后端开发的一种模式：m为Model，用于存储收发数据；c为Controller，用于协调控制；v为View(视图)，是用来显示数据的。 在mvc模式下，从数据库中加载的数据首先被封装在Model中，通过Controller，绑定到View上（视图可以理解为html的页面）。 所以控制器负责接收将数据交给浏览器与接收用户请求。用户操作时，实际上是→对控制器发出请求→控制器取用数据→交给视图→最终响应给用户。 两种注解 @Controller(无法前后端分离）：既有页面又有数据。 @RestController：只有数据。RestController（为了方便前端处理）会将返回的对象数据转换为JSON格式。 ","date":"2023-12-01","objectID":"/posts/springbootp3/:2:1","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"路由映射 控制器如何接收前端的请求 @RequestMapping(可以用在类或者方法上） value参数：用于配置路径，支持普通字符串与正则表达式。可以规定前端用什么方法请求（比如get或post） ","date":"2023-12-01","objectID":"/posts/springbootp3/:2:2","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"实际操作 使用@RequestMapping 加入value值：/hello。 使hello方法能够接收前端的请求，前端通过/hello路径能够访问到该方法。（在地址栏里面发送的请求都是get请求） 规定方法：加入method=RequestMethod.GET，规定只能通过get请求。(@RequestMapping(value=\"/hello\",method=RequestMethod.GET)等价于@GetMapping(\"/hello\")) ","date":"2023-12-01","objectID":"/posts/springbootp3/:2:3","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"参数传递 @RequestParam可以将前端的数据绑定到控制器的方法上以获取前端传递的信息。当传参与参数名一致时可省略。 此时只需要在方法里面加入一个参数：String nickname，就可自动将前端输入的昵称传入nickname中。 传参与定义参数名不一致，可以在方法里加入@RequestParam(value = \"nickname\",required = false)String name （代表参数映射,加上这个注解，就代表这个参数是必须的，如果希望可选就加上required = false) （如果必须，没输入会报错，报错结果为status=400，400一般意味着是客户端，也就是浏览器出了问题） 全部代码如下 创建entity实体包，在entity下创建User类(按住alt+insert快捷加入get/set/to String方法) public class User { public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private String username; private String password; @Override public String toString() { return \"User{\" + \"username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 在Controller包下创建ParamsController控制器类(后面的POST方法用APIPOST可以调试) @RestController public class ParamsController { @RequestMapping(value = \"/getTest1\",method = RequestMethod.GET) public String getTest1(){ return \"Get请求\"; } @RequestMapping(value =\"/getTest2\",method = RequestMethod.GET) public String getTest2(String nickname,String phone){ System.out.println(\"nickname\"+nickname); System.out.println(\"phone\"+phone); return \"GET请求\"; } @RequestMapping(value = \"/getTest3\",method = RequestMethod.GET) public String getTest3(@RequestParam(value = \"nickname\",required = false)String name){ //↑注解，代表参数映射，表示如果传参名字与参数不一致，就映射nickname System.out.println(\"nickname\"+name); return \"GET请求\"; } @RequestMapping(value = \"/postTest1\",method = RequestMethod.POST) public String postTest1(){ return \"POST请求\"; } @RequestMapping(value = \"/postTest2\",method = RequestMethod.POST) public String postTest2(String username,String password){ System.out.println(\"username:\"+username); System.out.println(\"password:\"+password); return \"POST请求\"; } @RequestMapping(value = \"/postTest3\",method = RequestMethod.POST) public String postTest3(User user){ System.out.println(user); return \"POST请求3\"; } @RequestMapping(value = \"/postTest4\",method = RequestMethod.POST) public String postTest4(@RequestBody User user){ System.out.println(user); return \"post请求\"; } @GetMapping(\"/test/**\") public String test(){ return \"通配符请求\"; } } ","date":"2023-12-01","objectID":"/posts/springbootp3/:2:4","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"APIPOST 可以模拟post请求 （本来需要通过专门的前端程序或者表单，这里可以通过APIPOST进行前端调试） （在地址栏里面发送的是get请求，不能直接/postTest（post请求的方法），会有405（4开头一般是浏览器的问题）） JSON类型需要使用{}传递 如果需要接收JSON类型的数据需要加一个单独的注解 @RequestBody 需要注意类型与参数名都要对的上 通配符（了解即可）/test/**,意味着/test/a/b/c都行。/test/*意味着只能/test/abcc。 ","date":"2023-12-01","objectID":"/posts/springbootp3/:3:0","tags":["个人学习","后端"],"title":"全栈学习·Springboot控制器/映射/前端传参\u0026APIPOST的应用","uri":"/posts/springbootp3/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"SpringBoot快速上手 ","date":"2023-11-30","objectID":"/posts/springbootp2/:1:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Springboot的介绍 Springboot旨在简化SSM（Spring\\SpringMVC\\Mybatis）的配置过程 ","date":"2023-11-30","objectID":"/posts/springbootp2/:1:1","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"Springboot的特点 之所以能够简化操作，Springboot做到了： 约定优于配置” ，用大量的默认配置代替手动配置的过程 使用内嵌的Tomcat，用户无需再手动打包war文件让服务器使用 定制Staters启动器，简化了Maven配置（帮你配置好了,简化以前可能需要写几十个依赖的情况,现在写一两个即可） 使用纯Java配置 后续维护时，Springboot提供了各种监控检测功能 （如若需要开发复杂项目还需继续学习Spring【不过Springboot完全够用了，除非是接口几千个的大项目，可能要考虑到后续并发量之类的问题，Springboot作为一个比较单体的东西，可能确实是不太应付得来】） ","date":"2023-11-30","objectID":"/posts/springbootp2/:1:2","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"创建Springboot应用 (IDEA2020.3) 创建 Group处一般输入公司域名 Artifact处输入项目名称 SDK:1.8 Java version:8【SDK17选择Java 17也无大碍】 Web→Spring Web 选择存放位置 右下角会显示下载依赖的进度条，如果持续太久了可能是下面的配置路径出了问题（需要修改过阿里云镜像，要不然就很慢） Settings→Build,Execution,Deployment→Build Tools→Maven 基本结构（基于maven） 代码位于src下的java目录 resources下放置一些资源（系统会自动放一些文件夹和配置目录） static放置网站的静态资源 templates放置网站的html之类的模板 application.properties为重要的配置文件（但springboot无需配置） test为java的测试 pom.xml parent标签，可以认为是一个副级的项目，我们现在就是依赖于这个项目，不需要多做配置 dependencies，一些依赖包 main→java→com.example.xxx是主包，后续我们要写什么都需要放进主包 启动程序为主包下的xxxApplication类 操作 在主包下创建controller包，创建xxxController类 在类中做**@RestController**标记以让此类变为控制器，可以接收客户端的请求 具体如何接收需要在类中加入public方法，返回类型为String： pubilic String xxx(){ return \"hello world\";} 期望为浏览器访问后端时，能够看到此字符串 加入一个注解：@GetMapping(\"/xxx\") 效果为浏览器可以发送http里的get请求来访问xxx()方法，具体访问方法时需要明确的链接地址：/xxx 浏览器如何访问？浏览器会固定使用\"http\"的协议，后加一个域名，再往后是具体路径/path:http://localhost:8080/path,上面的/xxx就是此处的路径，这样就可以访问刚刚写的方法（默认localhost:80，但80是可以省略的，一般访问本地主机就写成localhost，但是Tomcat访问的是8080端口，所以需要写成localhost:8080)。 全部代码如下 创建Controller包，包下创建HelloController类 @RestController public class HelloController { // →地址栏可以通过问号传参http://localhost:8080/hello?nickname=zhangsan // ↓等价于@RequestMapping(value = \"/hello\",method= RequestMethod.GET) @GetMapping(\"/hello\") public String hello(String nickname,String phone){ System.out.println(phone); return \"HELLO,WORLD(｡･∀･)ﾉﾞ！\"+nickname; } } 启动 找到xxxApplication启动类，启动程序 会在启动台里看见Springboot的标志 在浏览器输入localhost:8080/xxx 修改一定要重启项目（可以通过热部署解决） ","date":"2023-11-30","objectID":"/posts/springbootp2/:1:3","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2/"},{"categories":["SpringBoot+Vue全栈开发"],"content":"开发环境热部署 在pom.xml中加入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e 点击右上角的按钮，下载依赖 在application.properties配置devtools spring.devtools.restart.enabled=true spring.devtools.restart.additional-paths=src/main/java 打开Settings页面，在左边的菜单栏依次找到Build,Execution,Deployment一Compile，勾选 Build project automatically 按Ctrl+Shift+Alt+/快捷键调出Maintenance页面，单击Registry，勾选 compiler,automake.allow,when.app.running (IDEA2021版本的设置在Settings→Advanced Settings→Comiler里面) ","date":"2023-11-30","objectID":"/posts/springbootp2/:2:0","tags":["个人学习","后端"],"title":"全栈学习·SpringBoot介绍/特点/创建/结构\u0026热部署","uri":"/posts/springbootp2/"},{"categories":["角色照片"],"content":"白魔法师 👑\r💎\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:1:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"赤魔法师 💫\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:2:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"绝枪战士 🌹\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:3:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"机工士 🔫\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:4:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"舞者 💃\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:5:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"忍者 🕶\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:6:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"武士 🤺\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:7:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"刻木匠 🦨\r","date":"2023-05-01","objectID":"/posts/ff14secpicpostcard/:8:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(带白边)","uri":"/posts/ff14secpicpostcard/"},{"categories":["角色照片"],"content":"钐镰客 附身状态的镰刀，帅！！\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:1:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"白魔法师 纯白沙皇永远的神\r钻石幻杖冰雪主题真的美呆了\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:2:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"赤魔法师 生命之色涡旋流转……\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:3:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"绝枪战士 这不帅？这不帅？这不帅？\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:4:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"机工士 枪火重生，启动！\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:5:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"舞者 俺的兔娘是萨维奈红的最漂亮的那朵莲花\u003c(￣︶￣)↗\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:6:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"忍者 宁甲是最完美的职业！\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:7:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"武士 一句话，让舞者绑我三局舞伴：大家好，我是FF14精通Logs的讲师，我开场直暴2w8\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:8:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"},{"categories":["角色照片"],"content":"刻木匠 老桑，你的aibo我的爱\r","date":"2023-05-01","objectID":"/posts/ff14secpic/:9:0","tags":["游戏记录","FF14"],"title":"[FF14] 维埃拉族·特效约拍册(无边框)","uri":"/posts/ff14secpic/"}]